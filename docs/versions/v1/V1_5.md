# PACT v1.5

PACT v1.5 builds on the stable v1.0 foundation by adding provider identity modes and Know Your Agent (KYA) credential verification, without changing core protocol semantics.

---

## Summary

v1.5 introduces:

1. **Provider Identity Modes**: Flexible identity management for production deployments (env secret key, keypair file, dev seed, ephemeral)
2. **Credential Verification**: HTTP providers present signed credentials that buyers verify before negotiation
3. **Backward Compatibility**: All v1.0 guarantees remain unchanged; v1.5 is additive only

These features enhance security and identity verification while maintaining full compatibility with v1.0 providers and buyers.

---

## Provider Identity Modes

PACT v1.5 introduces production-ready provider identity management while preserving backward compatibility with v1.0 demos.

### Identity Loading Precedence

Provider identity is loaded in the following order (first available wins):

1. **`PACT_PROVIDER_SECRET_KEY_B58`** (env var)
   - Base58-encoded 64-byte Ed25519 secret key
   - Highest precedence for production deployments
   - Example: `export PACT_PROVIDER_SECRET_KEY_B58="<base58_secret_key>"`

2. **`PACT_PROVIDER_KEYPAIR_FILE`** (env var)
   - Path to JSON file containing:
     ```json
     {
       "secretKeyB58": "<base58_secret_key>",
       "publicKeyB58": "<base58_public_key>" // optional, validated if provided
     }
     ```
   - Example: `export PACT_PROVIDER_KEYPAIR_FILE="/path/to/keypair.json"`

3. **`PACT_DEV_IDENTITY_SEED`** (env var - explicit opt-in)
   - Deterministic dev identity seed (must be explicitly set)
   - **Warning**: Only for development/testing
   - Example: `export PACT_DEV_IDENTITY_SEED="my-dev-seed"`
   - If not set, falls back to ephemeral

4. **Ephemeral keypair** (fallback)
   - Random keypair generated on each server start
   - No warning (acceptable for testing/demos)
   - Identity changes on each restart

### Breaking Changes

- **v1.0 behavior preserved**: If no env vars are set, server uses ephemeral keypair (no warning)
- **v1.0 dev seed behavior**: Only used if `PACT_DEV_IDENTITY_SEED` is explicitly set
- **Warning messages**: Only printed for deterministic dev seed (mode 3), not for ephemeral

---

## Know Your Agent (KYA) Credentials

PACT v1.5 adds credential-based identity verification for HTTP providers, enabling buyers to verify provider capabilities before negotiation begins.

### Credential Schema

Credentials are signed capability attestations:

```typescript
{
  protocol_version: "pact/1.0",
  credential_version: "1",
  credential_id: string;              // Unique identifier
  provider_pubkey_b58: string;        // Provider's public key
  issuer: string;                     // For v1.5, allows "self" for self-signed
  issued_at_ms: number;
  expires_at_ms: number;
  capabilities: Array<{
    intentType: string;               // e.g., "weather.data"
    modes: ("hash_reveal" | "streaming")[];
    region?: string;
    credentials?: string[];            // e.g., ["sla_verified"]
  }>;
  nonce: string;                      // Random nonce
}
```

### Credential Endpoint

Providers expose credentials via:

```
GET /credential?intent=<intentType>
```

Returns a signed envelope containing the credential message.

### Credential Verification

Buyers automatically fetch and verify credentials for HTTP providers:

1. **Signature verification**: Credential envelope signature must be valid
2. **Signer match**: Credential signer must match provider's directory `pubkey_b58`
3. **Expiration check**: Credential must not be expired (`expires_at_ms >= now`)
4. **Capability check**: Credential must support the requested intent type

If any verification fails, the provider is marked ineligible with `PROVIDER_CREDENTIAL_INVALID`.

### Graceful Degradation

For backward compatibility with v1.0 providers that don't implement credentials:

- **404 Not Found**: Credential endpoint missing → Provider is allowed (legacy support)
- **Other errors**: Credential fetch/parse errors → Provider is marked ineligible

This ensures v1.5 buyers can still work with v1.0 providers while encouraging credential adoption.

### Integration with acquire()

Credential verification happens automatically in `acquire()` for HTTP providers:

- Runs **before** quote fetching (early rejection)
- Logged in explain decision log if `explain !== "none"`
- Failure code: `PROVIDER_CREDENTIAL_INVALID` with reason in explain log

---

## v1.0 Compatibility

All v1.0 guarantees remain unchanged:

- ✅ Protocol semantics (envelope signing, signer/pubkey match, commit-reveal verification)
- ✅ Receipt schema (unchanged)
- ✅ Settlement modes (hash_reveal, streaming)
- ✅ Failure codes (unchanged, with new additive codes)
- ✅ Deterministic outcomes
- ✅ Demo compatibility (all demos continue to work)

**Additive changes only**: v1.5 adds new optional features without breaking v1.0 behavior.

---

## Migration Guide

### For Provider Developers

**To use production identity:**
```bash
# Option 1: Environment variable
export PACT_PROVIDER_SECRET_KEY_B58="<your_base58_secret_key>"
pnpm provider:serve

# Option 2: Keypair file
export PACT_PROVIDER_KEYPAIR_FILE="/path/to/keypair.json"
pnpm provider:serve
```

**To implement credential endpoint:**
- Provider server automatically exposes `GET /credential`
- Credentials are self-signed by default (issuer: "self")
- Capabilities are configured in `handleCredential` (can be extended via config/env)

**For development/testing:**
- No changes needed — ephemeral keypairs work fine
- To use deterministic dev identity: `export PACT_DEV_IDENTITY_SEED="my-seed"`

### For Buyer Developers

**No changes required** — credential verification happens automatically.

- Credentials are verified transparently for HTTP providers
- Legacy providers (without credential endpoint) continue to work
- Use `explain: "coarse"` or `explain: "full"` to see credential verification in decision log

---

## New Failure Codes

v1.5 adds one new failure code (additive, not breaking):

- `PROVIDER_CREDENTIAL_INVALID`: Credential verification failed (signature, signer mismatch, expired, or intent not supported)

This code is only used when credential verification is attempted and fails. Providers without credential endpoints don't trigger this code (graceful degradation).

---

## Testing

All v1.0 tests continue to pass. New tests added:

- **Provider identity loading** (`packages/provider-adapter/src/__tests__/keypair.test.ts`)
- **Credential fetching** (`packages/sdk/src/adapters/http/__tests__/credential.test.ts`)
- **Credential verification in acquire()** (`packages/sdk/src/client/__tests__/acquire.test.ts`)

---

## Security Considerations

1. **Credential expiration**: Credentials include expiration times (1 year default in provider-adapter)
2. **Self-signed credentials**: v1.5 allows "self" issuer — buyers can verify provider pubkey matches directory
3. **Capability attestation**: Credentials explicitly state supported intent types and settlement modes
4. **Production identity**: Use `PACT_PROVIDER_SECRET_KEY_B58` or keypair files — never use dev seeds in production

---

## Reputation V2 (v1.5.3+)

v1.5.3 introduces credential-aware, volume-weighted reputation scoring to improve provider selection quality.

### Features

- **Volume-weighted scoring**: Uses `paid_amount` (or `agreed_price`) with logarithmic weighting to prevent micro-trade farming
- **Credential-aware**: Providers with verified credentials receive a small reputation boost (5%)
- **Enhanced penalties**: 
  - `FAILED_PROOF` imposes strong penalty on provider reputation (up to 80% reduction)
  - `BUYER_STOPPED` penalizes buyer reputation more than seller (up to 30% reduction)
- **Micro-trade protection**: Receipts with value < 1e-6 are treated as 0 weight

### Usage

Enable V2 scoring by setting `useReputationV2: true` in `acquire()` input. V2 scoring is only applied when:
- `useReputationV2` is enabled
- Credential verification succeeded (`credentialPresent: true`)

Otherwise, the system falls back to V1 scoring for backward compatibility.

The demo CLI enables V2 scoring by default for improved selection quality.

---

## TranscriptStore (v1.5.4+)

v1.5.4 introduces optional transcript saving for audit and debugging. Every `acquire()` call can emit a full JSON transcript capturing the entire acquisition flow.

### Features

- **Complete audit trail**: Captures directory, credential checks, quotes, selection, settlement, and receipt
- **Lightweight summaries**: Stores key information without huge payloads
- **Optional**: Enabled via `saveTranscript: true` in `acquire()` input
- **Custom directory**: Specify `transcriptDir` to override default location (`.pact/transcripts`)

### Usage

Enable transcript saving by setting `saveTranscript: true` in `acquire()` input:

```typescript
const result = await acquire({
  input: {
    intentType: "weather.data",
    scope: "NYC",
    constraints: { latency_ms: 50, freshness_sec: 10 },
    maxPrice: 0.0001,
    saveTranscript: true, // Enable transcript saving
    transcriptDir: "/path/to/transcripts", // Optional custom directory
  },
  // ... other params
});

// Transcript path is returned in result
if (result.transcriptPath) {
  console.log(`Transcript saved: ${result.transcriptPath}`);
}
```

The demo CLI enables transcripts by default for demo modes, or use `--saveTranscript` flag.

### Transcript Format

Transcripts are versioned JSON files (currently `version: "1"`) containing:
- Input parameters (sanitized)
- Directory of providers considered
- Credential verification results per provider
- Quote fetching results per provider
- Provider selection details
- Settlement summary (mode, artifacts, verification)
- Full receipt (if present)
- Decision log (if explain enabled)
- Outcome summary (success/failure)

---

## Transcript replay (v1.5.6+)

v1.5.6 adds transcript replay verification to audit saved transcripts and verify their integrity.

### Features

- **Filename uniqueness**: Transcripts are saved with format `<intent_id>-<timestamp_ms>.json` to prevent overwrites
- **Signature verification**: Verifies envelope signatures from explain decisions
- **Credential validation**: Checks credential expiration and signer matches
- **Commit-reveal verification**: Verifies hash matches when payload data is available
- **Graceful degradation**: Records `MISSING_ARTIFACT` failures without crashing

### Usage

```typescript
import { replayTranscript } from "@pact/sdk";

// Replay from file path
const result = await replayTranscript("./transcripts/intent-1000-1234567890.json");

// Or replay from object
const result = await replayTranscript(transcriptObject);

if (result.ok) {
  console.log("✅ Transcript verified successfully");
  console.log(`Envelopes verified: ${result.summary.envelopes_verified}`);
  console.log(`Credentials verified: ${result.summary.credentials_verified}`);
} else {
  console.error("❌ Transcript verification failed");
  result.failures.forEach(f => {
    console.error(`  ${f.code}: ${f.reason}`);
  });
}
```

### Verification Checks

The replay verifier checks:
- **Envelopes**: Signature verification for quote/credential/commit/reveal envelopes (if present in explain decisions)
- **Credentials**: Expiration checks and signer pubkey matching
- **Commit-reveal**: Hash verification when payload and nonce are available
- **Artifacts**: Records missing data as `MISSING_ARTIFACT` failures (non-fatal)

### Result Structure

```typescript
{
  ok: boolean,
  failures: Array<{
    code: string,        // e.g., "CREDENTIAL_EXPIRED", "ENVELOPE_VERIFICATION_FAILED"
    reason: string,
    context?: {...}
  }>,
  summary: {
    intent_id: string,
    intent_type: string,
    timestamp_ms: number,
    outcome: {...},
    envelopes_verified: number,
    envelopes_failed: number,
    credentials_verified: number,
    credentials_expired: number,
    commit_reveal_verified: number,
    commit_reveal_failed: number,
    artifacts_missing: number,
  }
}
```

---

## Credential Trust Tiers (v1.5.7+)

v1.5.7 introduces trust scoring for credentials, enabling buyers to evaluate provider credentials beyond simple verification.

### Features

- **Issuer-based trust**: Configure trusted issuers and their base trust weights
- **Trust score calculation**: Combines issuer weight with credential claims (SLA verification, region match, settlement mode support)
- **Trust tiers**: Categorizes credentials as "trusted" (≥0.7), "low" (≥0.3), or "untrusted" (<0.3)
- **Policy integration**: Trust requirements can be enforced via `require_trusted_issuer` and `min_trust_score`
- **Selection influence**: Trust scores provide small utility bonuses in provider selection (tie-breaks)
- **Reputation integration**: Trust scores multiply credential boosts in reputation V2 scoring

### Configuration

Trust configuration is part of the policy's `base.kya.trust` section:

```typescript
{
  base: {
    kya: {
      trust: {
        require_trusted_issuer: false,        // If true, only trusted issuers allowed
        trusted_issuers: ["self"],            // List of trusted issuer IDs
        issuer_weights: { "self": 0.2 },      // Base trust weight per issuer (0-1)
        min_trust_score: 0.0,                 // Minimum trust score required (0-1)
      }
    }
  }
}
```

**Defaults:**
- `require_trusted_issuer: false` - Allows any issuer (backward compatible)
- `trusted_issuers: ["self"]` - Only "self" issuer is trusted by default
- `issuer_weights: { "self": 0.2 }` - Self-signed credentials start at 0.2 trust
- `min_trust_score: 0.0` - No minimum trust requirement by default

### Trust Score Calculation

Trust scores are computed from:

1. **Base issuer weight**: `issuer_weights[issuer]` or `0` if issuer not found
2. **SLA verified boost**: `+0.1` if credential includes `"sla_verified"` claim
3. **Region match boost**: `+0.05` if credential region matches request region
4. **Settlement mode boost**: `+0.05` if credential supports requested settlement mode
5. **Clamp to [0, 1]**: Final score is clamped between 0 and 1

**Example:**
- Issuer: "self" (weight: 0.2)
- Claims: ["sla_verified"] (+0.1)
- Region match: "us-east" (+0.05)
- **Total trust score: 0.35** (tier: "low")

### Trust Requirements

Two policy knobs control trust enforcement:

1. **`require_trusted_issuer: true`**: Only issuers in `trusted_issuers` are allowed
   - Failure code: `PROVIDER_ISSUER_UNTRUSTED`
   - Provider is marked ineligible immediately

2. **`min_trust_score: 0.5`**: Providers must achieve minimum trust score
   - Failure code: `PROVIDER_CREDENTIAL_LOW_TRUST`
   - Provider is marked ineligible if trust score < minimum

### Integration Points

**acquire() eligibility:**
- Trust scoring runs after credential verification succeeds
- Trust failures mark provider ineligible with explain codes
- Trust scores are stored in provider evaluation context

**Selection utility:**
- Trust scores provide small utility bonus: `-0.02 * trust_score`
- Negative because lower utility is better
- Influences tie-breaks but doesn't dominate price/latency

**Reputation V2:**
- Credential boost (5%) is multiplied by trust score
- Trust score of 0.5 → 2.5% boost instead of 5%
- Trust score of 1.0 → full 5% boost

### Explain Codes

New explain codes for trust scoring:

- `PROVIDER_ISSUER_UNTRUSTED`: Issuer not in trusted list (when `require_trusted_issuer: true`)
- `PROVIDER_CREDENTIAL_LOW_TRUST`: Trust score below minimum threshold
- `PROVIDER_CREDENTIAL_TRUST_SCORE`: Trust score computed (logged in full explain mode)

### Future: External Attestors

The trust system is designed to support external attestors in future versions:

- **Third-party issuers**: Add issuer IDs to `trusted_issuers` (e.g., `["self", "acme-corp", "trusted-validator"]`)
- **Issuer weights**: Configure different base weights per issuer (e.g., `{ "self": 0.2, "acme-corp": 0.8 }`)
- **Credential chains**: Support for credential delegation and chaining (future work)

For now, all credentials are self-signed (`issuer: "self"`), but the infrastructure is ready for external attestors.

---

## Trust Tier Routing (v1.5.8+)

v1.5.8 builds on credential trust tiers (v1.5.7) by adding trust-based routing and eligibility gating, allowing buyers to require minimum trust tiers/scores for provider selection.

### Features

- **Trust requirement enforcement**: Gate providers based on credential presence, issuer trust, tier, and score
- **Buyer overrides**: Override policy trust requirements per-request via `acquire()` input
- **Trust-aware routing**: Selection prefers higher-trust providers when all else equal
- **Backward compatible**: Default behavior unchanged; trust gates are opt-in

### Configuration

Trust routing extends the policy's `base.kya.trust` section from v1.5.7:

```typescript
{
  base: {
    kya: {
      trust: {
        require_trusted_issuer: false,        // If true, only trusted issuers allowed
        require_credential: false,            // If true, credential is required (v1.5.8+)
        trusted_issuers: ["self"],            // List of trusted issuer IDs
        issuer_weights: { "self": 0.2 },      // Base trust weight per issuer (0-1)
        min_trust_tier: "untrusted",          // Minimum trust tier required: "untrusted" | "low" | "trusted" (v1.5.8+)
        min_trust_score: 0.0,                 // Minimum trust score required (0-1)
      }
    }
  }
}
```

**New defaults (v1.5.8):**
- `require_credential: false` - Credential not required (backward compatible)
- `min_trust_tier: "untrusted"` - No tier requirement by default

### Buyer Overrides

Buyers can override policy trust requirements per-request:

```typescript
const result = await acquire({
  input: {
    intentType: "weather.data",
    scope: "NYC",
    constraints: { latency_ms: 50, freshness_sec: 10 },
    maxPrice: 0.0001,
    // Trust overrides (v1.5.8+)
    requireCredential: true,        // Override policy require_credential
    minTrustTier: "trusted",        // Override policy min_trust_tier
    minTrustScore: 0.7,             // Override policy min_trust_score
  },
  // ... other params
});
```

**Precedence**: If buyer sets a field, it overrides policy for that request. Otherwise, use compiled policy defaults.

### Trust Requirement Enforcement

Trust requirements are enforced in this order (provider marked ineligible if any check fails):

1. **`requireCredential` check**: If `true` and credential missing → `PROVIDER_CREDENTIAL_REQUIRED`
2. **`require_trusted_issuer` check**: If `true` and issuer not in trusted list → `PROVIDER_ISSUER_UNTRUSTED`
3. **`minTrustTier` check**: If provider tier < required tier → `PROVIDER_TRUST_TIER_TOO_LOW`
4. **`minTrustScore` check**: If provider score < required score → `PROVIDER_TRUST_SCORE_TOO_LOW`

Tier ordering: `untrusted` (0) < `low` (1) < `trusted` (2)

### Trust-Aware Routing

When multiple providers are eligible, selection prefers higher-trust providers via utility bonus:

- **Trusted tier**: `-0.05` utility bonus (lower utility = better)
- **Low tier**: `-0.02` utility bonus
- **Trust score**: Additional `-0.02 * trust_score` bonus

This bonus influences tie-breaks but doesn't dominate price/latency. When all else equal, trusted providers are selected over low/untrusted.

**Example**: Two providers with identical price/latency:
- Provider A: Trusted tier (0.8 score) → utility bonus = -0.05 - 0.02*0.8 = -0.066
- Provider B: Low tier (0.3 score) → utility bonus = -0.02 - 0.02*0.3 = -0.026
- Result: Provider A selected (lower utility)

### Explain Codes

New explain codes for trust routing (v1.5.8+):

- `PROVIDER_CREDENTIAL_REQUIRED`: Credential required but provider doesn't present one
- `PROVIDER_TRUST_TIER_TOO_LOW`: Provider trust tier below minimum requirement
- `PROVIDER_TRUST_SCORE_TOO_LOW`: Provider trust score below minimum requirement

Meta fields in full explain mode:
- `trust_score`: Provider's computed trust score
- `tier`: Provider's trust tier ("untrusted" | "low" | "trusted")
- `min_trust_tier`: Minimum tier required
- `min_trust_score`: Minimum score required
- `require_credential`: Whether credential was required

### Integration Points

**acquire() eligibility:**
- Trust requirements checked after credential verification
- Failures mark provider ineligible with explain codes
- Trust score/tier stored in provider evaluation context

**Selection utility:**
- Trust bonuses applied to utility calculation
- Prefers higher-trust providers when price/latency equal

**Protocol unchanged:**
- Trust routing is eligibility/selection only
- Settlement, commit-reveal, streaming, receipts unchanged
- No protocol semantic changes

### Usage Examples

**Require credentials for all providers:**
```typescript
const policy = createDefaultPolicy();
policy.base.kya.trust.require_credential = true;

const result = await acquire({
  input: { /* ... */ },
  policy,
  // ... other params
});
```

**Require trusted tier (buyer override):**
```typescript
const result = await acquire({
  input: {
    // ... other fields
    minTrustTier: "trusted",
    explain: "full",
  },
  // ... other params
});
```

**Combine policy + buyer override:**
```typescript
// Policy sets base requirements
const policy = createDefaultPolicy();
policy.base.kya.trust.require_credential = true;
policy.base.kya.trust.min_trust_tier = "low";

// Buyer can tighten per-request
const result = await acquire({
  input: {
    // ... other fields
    minTrustTier: "trusted", // Tighter than policy's "low"
  },
  policy,
  // ... other params
});
```

### Backward Compatibility

All v1.5.7 guarantees remain unchanged:
- ✅ Default behavior: `require_credential: false`, `min_trust_tier: "untrusted"` (no gating)
- ✅ Existing demos work unchanged (no trust requirements enforced)
- ✅ Legacy providers without credentials continue to work (unless `requireCredential: true`)
- ✅ Protocol semantics unchanged (routing/eligibility only)

**Additive changes only**: v1.5.8 adds optional trust gating without breaking v1.5.7 behavior.

---

## Settlement seam (v1.5.5+)

v1.5.5 formalizes the settlement interface, preparing PACT for external payment rails while maintaining backward compatibility.

### Payment-Rail Agnostic Design

PACT is **payment-rail agnostic**. The `SettlementProvider` interface is the integration point for any payment system:
- **Custodial APIs** (Stripe, PayPal, bank APIs)
- **On-chain wallets** (Ethereum, Solana, other blockchains)
- **Payment processors** (Square, Adyen, etc.)
- **Streaming meters** (usage-based billing systems)
- **Mock providers** (for testing and development)

### Implementation Status

- **MockSettlementProvider**: Fully implemented (default for demos and tests)
- **ExternalSettlementProvider**: Stub implementation (throws `NotImplemented` errors)
  - Serves as template for real payment rail integrations
  - Constructor takes config: `{ rail: string, network?: string, credentials?: unknown }`
  - Real implementations should replace stub methods with actual payment logic

### Core Interface

The `SettlementProvider` interface defines:
- `getBalance(agentId)`: Get available balance
- `getLocked(agentId)`: Get locked balance
- `lock(agentId, amount)`: Lock funds (throws on insufficient balance)
- `release(agentId, amount)`: Release locked funds
- `pay(from, to, amount, meta?)`: Transfer funds (throws on insufficient balance)
- `slashBond(providerId, amount, beneficiaryId, meta?)`: Slash provider bond

Legacy methods (`lockFunds`, `lockBond`, `unlock`, `slash`, etc.) are maintained for backward compatibility.

---

## What's Next

Possible future enhancements (not in v1.5):

- **External wallet integration**: Direct integration with external wallet providers for key management
- **Third-party credential issuers**: Beyond self-signed credentials, support for trusted third-party issuers
- **Credential revocation lists**: Mechanisms to revoke compromised or expired credentials
- **Credential chaining / delegation**: Support for credential chains and delegated attestations
- **Hardware security module (HSM) integration**: Enhanced security for production key management
- **Credential refresh / rotation**: Automated credential renewal and rotation workflows

These features may be considered for future versions but are explicitly **not** in v1.5.

