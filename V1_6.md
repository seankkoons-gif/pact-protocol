# PACT v1.6

PACT v1.6 builds on v1.5 by adding settlement lifecycle management and idempotency, preparing for external payment rail integration without changing core protocol semantics.

---

## Summary

v1.6 introduces:

1. **Settlement Lifecycle API**: Structured prepare/commit/abort workflow for settlement operations
2. **Idempotency**: Safe retries via deterministic handle IDs and idempotent operations
3. **Backward Compatibility**: All existing settlement methods (lock/pay/release/slashBond) remain unchanged

These features enable reliable settlement operations and prepare for integration with external payment rails while maintaining full backward compatibility with v1.5.

---

## Settlement Lifecycle (v1.6.1+)

v1.6.1 introduces a formal lifecycle API for settlement operations, enabling idempotent settlement workflows and preparing for external payment rail integration.

### Overview

The settlement lifecycle follows a three-phase model:

1. **Prepare**: Lock funds and create a settlement handle
2. **Commit**: Transfer locked funds from buyer to seller
3. **Abort**: Release locked funds back to buyer

All operations are **idempotent**: repeated calls with the same parameters return the same result without side effects.

### Types

```typescript
interface SettlementIntent {
  intent_id: string;           // Intent identifier
  from: string;                // Buyer agent ID
  to: string;                  // Seller agent ID
  amount: number;              // Amount to settle (>= 0)
  mode: "hash_reveal" | "streaming";  // Settlement mode
  meta?: Record<string, unknown>;      // Optional metadata
  idempotency_key?: string;    // Optional idempotency key for retries
}

interface SettlementHandle {
  handle_id: string;           // Deterministic handle ID
  intent_id: string;           // Intent identifier
  status: "prepared" | "committed" | "aborted";
  locked_amount: number;       // Amount locked in prepare
  created_at_ms: number;       // Creation timestamp
  meta?: Record<string, unknown>;  // Optional metadata
}

interface SettlementResult {
  ok: boolean;
  status: "prepared" | "committed" | "aborted";
  paid_amount: number;         // Amount actually paid
  handle_id: string;           // Settlement handle ID
  meta?: Record<string, unknown>;  // Optional metadata
}
```

### API Methods

#### `prepare(intent: SettlementIntent): Promise<SettlementHandle>`

Locks funds and creates a settlement handle.

**Behavior:**
- Validates funds (throws if insufficient balance)
- Locks amount from buyer's available balance
- Creates deterministic handle_id from `intent_id + idempotency_key` (SHA-256 hash)
- **Idempotent**: Repeated calls with same `(intent_id, idempotency_key)` return same handle

**Invariants:**
- `getBalance(from)` decreases by `amount`
- `getLocked(from)` increases by `amount`
- Handle status is `"prepared"`

**Example:**
```typescript
const intent: SettlementIntent = {
  intent_id: "intent-123",
  from: "buyer-pubkey",
  to: "seller-pubkey",
  amount: 0.1,
  mode: "hash_reveal",
  idempotency_key: "retry-abc", // Optional, for retry safety
};

const handle = await settlement.prepare(intent);
// handle.handle_id is deterministic based on intent_id + idempotency_key
// handle.status === "prepared"
```

#### `commit(handle_id: string): Promise<SettlementResult>`

Commits prepared settlement by transferring locked funds.

**Behavior:**
- Transfers locked funds from buyer to seller
- Updates handle status to `"committed"`
- **Idempotent**: Repeated calls return same result (no double-payment)

**Preconditions:**
- Handle must exist
- Handle status must be `"prepared"` (throws if `"committed"` or `"aborted"`)

**Invariants:**
- `getLocked(from)` decreases by `amount`
- `getBalance(to)` increases by `amount`
- Handle status changes from `"prepared"` to `"committed"`

**Example:**
```typescript
const result = await settlement.commit(handle.handle_id);
// result.status === "committed"
// result.paid_amount === 0.1

// Idempotent: safe to call multiple times
const result2 = await settlement.commit(handle.handle_id);
// result2 === result (same handle_id, same paid_amount)
```

#### `abort(handle_id: string, reason?: string): Promise<void>`

Aborts prepared settlement by releasing locked funds.

**Behavior:**
- Releases locked funds back to buyer's available balance
- Updates handle status to `"aborted"`
- **Idempotent**: Repeated calls succeed (safe to call multiple times)

**Preconditions:**
- Handle must exist
- Handle status must be `"prepared"` (throws if `"committed"`)

**Invariants:**
- `getLocked(from)` decreases by `amount`
- `getBalance(from)` increases by `amount`
- Handle status changes from `"prepared"` to `"aborted"`

**Example:**
```typescript
await settlement.abort(handle.handle_id, "Negotiation failed");

// Idempotent: safe to call multiple times
await settlement.abort(handle.handle_id); // No-op, already aborted
```

### Idempotency

All lifecycle operations are **idempotent** to enable safe retries:

- **`prepare()`**: Same `(intent_id, idempotency_key)` returns same handle (no double-locking)
- **`commit()`**: Same `handle_id` returns same result (no double-payment)
- **`abort()`**: Same `handle_id` succeeds (idempotent abort is safe)

**Handle ID Generation:**
- Deterministic: `SHA-256(intent_id + ":" + idempotency_key)`
- Encoded as base58 for shorter IDs
- Same inputs → same handle_id → same handle

**Example (Retry Safety):**
```typescript
// Network failure during prepare - safe to retry
let handle: SettlementHandle;
try {
  handle = await settlement.prepare(intent);
} catch (error) {
  // Retry (idempotent)
  handle = await settlement.prepare(intent); // Returns same handle if first succeeded
}

// Network failure during commit - safe to retry
try {
  await settlement.commit(handle.handle_id);
} catch (error) {
  // Retry (idempotent)
  await settlement.commit(handle.handle_id); // No double-payment
}
```

### Integration with Existing Code

The lifecycle API is **additive** and does not replace existing settlement methods:

- **Existing methods unchanged**: `lock()`, `pay()`, `release()`, `slashBond()`, etc.
- **Backward compatible**: All v1.5 demos work unchanged
- **MockSettlementProvider**: Implements lifecycle using existing methods internally

**Minimal Integration:**
- Exchange/engine code continues using existing settlement methods
- Lifecycle API is available but not required (opt-in)
- Future integration with external payment rails will use lifecycle API

### Implementation Status

- **MockSettlementProvider**: ✅ Full implementation with idempotency
- **ExternalSettlementProvider**: ✅ Stub implementation (throws `NotImplemented`)
- **Integration**: TODO (existing code unchanged, lifecycle available but not used)

### Testing

Comprehensive tests cover:
- ✅ Prepare idempotency (same handle for same inputs)
- ✅ Commit idempotency (no double-payment)
- ✅ Abort idempotency (safe repeated calls)
- ✅ State transitions (prepare → commit, prepare → abort)
- ✅ Error handling (insufficient balance, invalid states)
- ✅ Handle ID determinism (same inputs → same handle_id)

See `packages/sdk/src/settlement/__tests__/lifecycle.test.ts` for full test coverage.

### Backward Compatibility

All v1.5 guarantees remain unchanged:
- ✅ Existing settlement methods work identically
- ✅ Demos continue to work unchanged
- ✅ Protocol semantics unchanged (lifecycle is settlement-layer only)

**Additive changes only**: v1.6.1 adds optional lifecycle API without breaking v1.5 behavior.

---

## Settlement Provider Selection (v1.6.2+)

v1.6.2 adds explicit settlement provider selection via `acquire()` input configuration, enabling runtime selection between mock and external providers while maintaining full backward compatibility.

### Overview

The settlement provider selection feature allows buyers to specify which settlement provider to use via `input.settlement` configuration, enabling:

- **Runtime provider selection**: Choose provider at request time without code changes
- **External provider integration**: Prepare for real payment rail integration
- **Backward compatibility**: Default behavior unchanged (existing demos work unchanged)

### Configuration

Settlement provider selection is configured via `input.settlement`:

```typescript
const result = await acquire({
  input: {
    intentType: "weather.data",
    scope: "NYC",
    constraints: { latency_ms: 50, freshness_sec: 10 },
    maxPrice: 0.0001,
    // Settlement provider selection (v1.6.2+)
    settlement: {
      provider: "mock" | "external",
      params?: Record<string, unknown>,  // Parameters for external provider
      idempotency_key?: string,          // Optional idempotency key for lifecycle
    },
  },
  // ... other params
});
```

**Fields:**
- `provider`: Settlement provider type (`"mock"` or `"external"`)
- `params`: Provider-specific parameters (required for `"external"`)
  - For `"external"`: Requires `{ rail: string, network?: string, credentials?: unknown }`
- `idempotency_key`: Optional idempotency key for settlement lifecycle operations (v1.6.1+)

### Provider Types

#### Mock Provider

Default provider for tests and demos:

```typescript
settlement: {
  provider: "mock",
}
```

- In-memory account balances
- Synchronous operations
- No external dependencies
- Suitable for testing and demos

#### External Provider

Stub for real payment rail integration:

```typescript
settlement: {
  provider: "external",
  params: {
    rail: "stripe",        // Payment rail identifier
    network: "testnet",    // Optional: network identifier
    credentials: { ... },  // Optional: API keys, wallet seeds, etc.
  },
}
```

- Currently throws `NotImplemented` errors
- Template for real implementations (Stripe, Ethereum, Solana, etc.)
- Requires implementation to work

**Example External Providers:**
- `rail: "stripe"` → Stripe payment API
- `rail: "ethereum"` → Ethereum smart contracts
- `rail: "solana"` → Solana program integration
- `rail: "custodial"` → Custodial wallet API

### Precedence

Settlement provider selection follows this precedence:

1. **`input.settlement.provider`** (highest priority)
   - If provided, creates provider via factory
   - Overrides explicit `settlement` parameter

2. **Explicit `settlement` parameter** (backward compatible)
   - If no `input.settlement.provider`, uses explicit parameter
   - Maintains backward compatibility with existing code

3. **Default behavior** (fallback)
   - Demos pass explicit `MockSettlementProvider`
   - This continues to work unchanged

**Example:**
```typescript
// Explicit settlement parameter wins (if no input.settlement.provider)
await acquire({
  input: { /* ... */ },  // No settlement config
  settlement: mockProvider,  // Uses this
  // ...
});

// Input config wins (if provided)
await acquire({
  input: {
    // ...
    settlement: { provider: "external", params: { rail: "stripe" } },
  },
  settlement: mockProvider,  // Ignored - input config used instead
  // ...
});
```

### Error Handling

When `provider: "external"` is selected, settlement operations throw `NotImplemented` errors. These are caught and returned as clean `acquire()` failures:

**Error Code:** `SETTLEMENT_PROVIDER_NOT_IMPLEMENTED`

**Example:**
```typescript
const result = await acquire({
  input: {
    // ...
    settlement: {
      provider: "external",
      params: { rail: "stripe" },
    },
  },
  // ...
});

if (!result.ok && result.code === "SETTLEMENT_PROVIDER_NOT_IMPLEMENTED") {
  console.error(`External settlement provider not implemented: ${result.reason}`);
}
```

**Error Handling Points:**
- Provider creation (factory errors)
- Settlement operations (credit, unlock, streamTick, etc.)
- Exchange operations (streaming tick, commit, etc.)

All `NotImplemented` errors from `ExternalSettlementProvider` are caught and returned as `SETTLEMENT_PROVIDER_NOT_IMPLEMENTED` with a descriptive reason.

### Factory Function

The settlement provider factory (`createSettlementProvider`) creates provider instances:

```typescript
import { createSettlementProvider } from "@pact/sdk";

const provider = createSettlementProvider({
  provider: "mock",
});

// or

const externalProvider = createSettlementProvider({
  provider: "external",
  params: {
    rail: "stripe",
    network: "testnet",
  },
});
```

**Factory Behavior:**
- `provider: "mock"` → Returns `new MockSettlementProvider()`
- `provider: "external"` → Returns `new ExternalSettlementProvider(params)`
- Invalid provider → Throws `Error` with clear message
- Missing params for external → Throws `Error` with validation message

### Usage Examples

**Mock Provider (Default):**
```typescript
const result = await acquire({
  input: {
    // ...
    settlement: {
      provider: "mock",
    },
  },
  // ... other params
});
```

**External Provider (Stub):**
```typescript
const result = await acquire({
  input: {
    // ...
    settlement: {
      provider: "external",
      params: {
        rail: "stripe",
        network: "testnet",
        credentials: {
          apiKey: process.env.STRIPE_API_KEY,
        },
      },
    },
  },
  // ... other params
});

if (!result.ok && result.code === "SETTLEMENT_PROVIDER_NOT_IMPLEMENTED") {
  // External provider not implemented yet
  console.warn("Real payment rail integration pending");
}
```

**With Idempotency Key:**
```typescript
const result = await acquire({
  input: {
    // ...
    settlement: {
      provider: "mock",
      idempotency_key: "retry-abc-123",  // For lifecycle operations
    },
  },
  // ... other params
});
```

### Integration with Lifecycle API

Settlement provider selection integrates with the lifecycle API (v1.6.1+):

- `idempotency_key` from `input.settlement` is available for lifecycle operations
- External providers can implement lifecycle methods (`prepare`, `commit`, `abort`)
- Mock provider fully implements lifecycle API with idempotency

**Example:**
```typescript
const result = await acquire({
  input: {
    // ...
    settlement: {
      provider: "mock",
      idempotency_key: "intent-123-retry-1",  // Used in prepare()
    },
  },
  // ... other params
});

// Lifecycle operations can use the idempotency_key from input.settlement
```

### Backward Compatibility

All v1.6.1 guarantees remain unchanged:
- ✅ Default behavior: No `input.settlement.provider` → uses explicit `settlement` parameter (unchanged)
- ✅ Existing demos work unchanged (pass explicit `MockSettlementProvider`)
- ✅ Protocol semantics unchanged (provider selection is settlement-layer only)

**Additive changes only**: v1.6.2 adds optional provider selection without breaking v1.6.1 behavior.

---

## Settlement Lifecycle in Transcripts (v1.6.3+)

v1.6.3 adds settlement lifecycle metadata to transcripts, enabling audit trails and replay validation for settlement operations.

### Overview

Transcripts now include optional `settlement_lifecycle` metadata that records:

- **Provider type**: Which settlement provider was used (`"mock"` or `"external"`)
- **Idempotency key**: The idempotency key from `input.settlement.idempotency_key` (if provided)
- **Lifecycle status**: Current lifecycle state (`"prepared"`, `"committed"`, or `"aborted"`)
- **Timestamps**: When lifecycle operations occurred (`prepared_at_ms`, `committed_at_ms`, `aborted_at_ms`)
- **Paid amount**: Amount paid (for committed settlements)
- **Errors**: Array of lifecycle errors (if any)

### Transcript Schema

```typescript
interface TranscriptV1 {
  // ... existing fields ...
  settlement_lifecycle?: {
    provider?: string;                    // "mock" | "external"
    idempotency_key?: string;             // From input.settlement.idempotency_key
    handle_id?: string;                   // Settlement handle ID from prepare()
    status?: "prepared" | "committed" | "aborted";
    prepared_at_ms?: number;              // Timestamp when prepare() was called
    committed_at_ms?: number;             // Timestamp when commit() was called
    aborted_at_ms?: number;               // Timestamp when abort() was called
    paid_amount?: number;                 // Amount paid (from commit result)
    errors?: Array<{                      // Lifecycle errors
      code: string;
      reason: string;
    }>;
  };
}
```

### Recording Lifecycle Metadata

Lifecycle metadata is automatically recorded when transcripts are saved:

**Provider Selection:**
- If `input.settlement.provider` is set, it's recorded in `settlement_lifecycle.provider`
- If `input.settlement.idempotency_key` is set, it's recorded in `settlement_lifecycle.idempotency_key`

**Status Recording:**
- On successful completion: `status: "committed"` with `paid_amount` and `committed_at_ms`
- On errors: `status: "aborted"` with `errors` array and `aborted_at_ms`
- Lifecycle errors are recorded when settlement operations fail (e.g., `SETTLEMENT_PROVIDER_NOT_IMPLEMENTED`)

**Example:**
```typescript
const result = await acquire({
  input: {
    intentType: "weather.data",
    scope: "NYC",
    constraints: { latency_ms: 50, freshness_sec: 10 },
    maxPrice: 0.0001,
    settlement: {
      provider: "mock",
      idempotency_key: "retry-abc-123",
    },
    saveTranscript: true,
    transcriptDir: ".pact/transcripts",
  },
  // ... other params
});

// Transcript includes:
// settlement_lifecycle: {
//   provider: "mock",
//   idempotency_key: "retry-abc-123",
//   status: "committed",
//   committed_at_ms: 1710000000,
//   paid_amount: 0.0001,
// }
```

### Replay Validation

The transcript replay verifier (`replayTranscript`) validates settlement lifecycle invariants:

**Validation Rules:**
- If `status === "committed"`: `paid_amount` must be present and > 0, `committed_at_ms` must be present
- If `status === "aborted"`: `paid_amount` must be absent or 0
- If `status === "prepared"`: `handle_id` must be present, `prepared_at_ms` must be present

**Validation Failures:**
- Failure code: `SETTLEMENT_LIFECYCLE_INVALID`
- Recorded in `replayResult.failures` with descriptive reason
- Does not throw; records failures in result

**Example:**
```typescript
import { replayTranscript } from "@pact/sdk";

const result = await replayTranscript(transcriptPath);

if (!result.ok) {
  for (const failure of result.failures) {
    if (failure.code === "SETTLEMENT_LIFECYCLE_INVALID") {
      console.error(`Settlement lifecycle invalid: ${failure.reason}`);
    }
  }
}

// Summary includes:
// summary.settlement_lifecycle_verified: number
// summary.settlement_lifecycle_failed: number
```

### Usage Examples

**Successful Settlement (Committed):**
```typescript
const transcript: TranscriptV1 = {
  // ... other fields ...
  outcome: { ok: true },
  settlement_lifecycle: {
    provider: "mock",
    idempotency_key: "test-key-123",
    status: "committed",
    committed_at_ms: 1710000000,
    paid_amount: 0.001,
  },
};

const result = await replayTranscript(transcript);
expect(result.ok).toBe(true);
expect(result.summary.settlement_lifecycle_verified).toBeGreaterThan(0);
```

**Failed Settlement (Aborted):**
```typescript
const transcript: TranscriptV1 = {
  // ... other fields ...
  outcome: {
    ok: false,
    code: "SETTLEMENT_PROVIDER_NOT_IMPLEMENTED",
  },
  settlement_lifecycle: {
    provider: "external",
    idempotency_key: "test-key-external",
    status: "aborted",
    aborted_at_ms: 1710000000,
    errors: [
      {
        code: "SETTLEMENT_PROVIDER_NOT_IMPLEMENTED",
        reason: "Settlement operation (credit) failed: ExternalSettlementProvider not implemented",
      },
    ],
  },
};

const result = await replayTranscript(transcript);
expect(result.ok).toBe(false);
expect(result.failures.some(f => f.code === "SETTLEMENT_LIFECYCLE_INVALID")).toBe(false); // Valid aborted state
```

**Invalid Transcript (Validation Failure):**
```typescript
const invalidTranscript: TranscriptV1 = {
  // ... other fields ...
  settlement_lifecycle: {
    provider: "mock",
    status: "committed",
    committed_at_ms: 1710000000,
    // paid_amount missing - invalid!
  },
};

const result = await replayTranscript(invalidTranscript);
expect(result.ok).toBe(false);
expect(result.failures.some(f => f.code === "SETTLEMENT_LIFECYCLE_INVALID")).toBe(true);
expect(result.summary.settlement_lifecycle_failed).toBeGreaterThan(0);
```

### Testing

Comprehensive tests cover:
- ✅ Lifecycle metadata recording for successful settlements
- ✅ Lifecycle error recording for failed settlements
- ✅ Replay validation of lifecycle invariants
- ✅ Invalid state detection (committed without paid_amount, aborted with paid_amount > 0, etc.)

See `packages/sdk/src/transcript/__tests__/settlement_lifecycle.test.ts` for full test coverage.

### Backward Compatibility

All v1.6.2 guarantees remain unchanged:
- ✅ `settlement_lifecycle` is optional (transcripts without it are valid)
- ✅ Existing transcript replay continues to work unchanged
- ✅ Protocol semantics unchanged (lifecycle metadata is audit-only)

**Additive changes only**: v1.6.3 adds optional lifecycle metadata to transcripts without breaking v1.6.2 behavior.

---

## What's Next

Possible future enhancements (not in v1.6):

- **External payment rail integration**: Real implementations of `ExternalSettlementProvider` for Stripe, Ethereum, etc.
- **Async settlement**: Support for async operations (e.g., on-chain confirmation)
- **Settlement webhooks**: Callback support for external payment rails
- **Multi-signature settlement**: Support for governance-required settlements

These features may be considered for future versions but are explicitly **not** in v1.6.

