# PACT v1.6

PACT v1.6 builds on v1.5 by adding settlement lifecycle management and idempotency, preparing for external payment rail integration without changing core protocol semantics.

---

## Summary

v1.6 introduces:

1. **Settlement Lifecycle API**: Structured prepare/commit/abort workflow for settlement operations
2. **Idempotency**: Safe retries via deterministic handle IDs and idempotent operations
3. **Backward Compatibility**: All existing settlement methods (lock/pay/release/slashBond) remain unchanged

These features enable reliable settlement operations and prepare for integration with external payment rails while maintaining full backward compatibility with v1.5.

---

## Settlement Lifecycle (v1.6.1+)

v1.6.1 introduces a formal lifecycle API for settlement operations, enabling idempotent settlement workflows and preparing for external payment rail integration.

### Overview

The settlement lifecycle follows a three-phase model:

1. **Prepare**: Lock funds and create a settlement handle
2. **Commit**: Transfer locked funds from buyer to seller
3. **Abort**: Release locked funds back to buyer

All operations are **idempotent**: repeated calls with the same parameters return the same result without side effects.

### Types

```typescript
interface SettlementIntent {
  intent_id: string;           // Intent identifier
  from: string;                // Buyer agent ID
  to: string;                  // Seller agent ID
  amount: number;              // Amount to settle (>= 0)
  mode: "hash_reveal" | "streaming";  // Settlement mode
  meta?: Record<string, unknown>;      // Optional metadata
  idempotency_key?: string;    // Optional idempotency key for retries
}

interface SettlementHandle {
  handle_id: string;           // Deterministic handle ID
  intent_id: string;           // Intent identifier
  status: "prepared" | "committed" | "aborted";
  locked_amount: number;       // Amount locked in prepare
  created_at_ms: number;       // Creation timestamp
  meta?: Record<string, unknown>;  // Optional metadata
}

interface SettlementResult {
  ok: boolean;
  status: "prepared" | "committed" | "aborted";
  paid_amount: number;         // Amount actually paid
  handle_id: string;           // Settlement handle ID
  meta?: Record<string, unknown>;  // Optional metadata
}
```

### API Methods

#### `prepare(intent: SettlementIntent): Promise<SettlementHandle>`

Locks funds and creates a settlement handle.

**Behavior:**
- Validates funds (throws if insufficient balance)
- Locks amount from buyer's available balance
- Creates deterministic handle_id from `intent_id + idempotency_key` (SHA-256 hash)
- **Idempotent**: Repeated calls with same `(intent_id, idempotency_key)` return same handle

**Invariants:**
- `getBalance(from)` decreases by `amount`
- `getLocked(from)` increases by `amount`
- Handle status is `"prepared"`

**Example:**
```typescript
const intent: SettlementIntent = {
  intent_id: "intent-123",
  from: "buyer-pubkey",
  to: "seller-pubkey",
  amount: 0.1,
  mode: "hash_reveal",
  idempotency_key: "retry-abc", // Optional, for retry safety
};

const handle = await settlement.prepare(intent);
// handle.handle_id is deterministic based on intent_id + idempotency_key
// handle.status === "prepared"
```

#### `commit(handle_id: string): Promise<SettlementResult>`

Commits prepared settlement by transferring locked funds.

**Behavior:**
- Transfers locked funds from buyer to seller
- Updates handle status to `"committed"`
- **Idempotent**: Repeated calls return same result (no double-payment)

**Preconditions:**
- Handle must exist
- Handle status must be `"prepared"` (throws if `"committed"` or `"aborted"`)

**Invariants:**
- `getLocked(from)` decreases by `amount`
- `getBalance(to)` increases by `amount`
- Handle status changes from `"prepared"` to `"committed"`

**Example:**
```typescript
const result = await settlement.commit(handle.handle_id);
// result.status === "committed"
// result.paid_amount === 0.1

// Idempotent: safe to call multiple times
const result2 = await settlement.commit(handle.handle_id);
// result2 === result (same handle_id, same paid_amount)
```

#### `abort(handle_id: string, reason?: string): Promise<void>`

Aborts prepared settlement by releasing locked funds.

**Behavior:**
- Releases locked funds back to buyer's available balance
- Updates handle status to `"aborted"`
- **Idempotent**: Repeated calls succeed (safe to call multiple times)

**Preconditions:**
- Handle must exist
- Handle status must be `"prepared"` (throws if `"committed"`)

**Invariants:**
- `getLocked(from)` decreases by `amount`
- `getBalance(from)` increases by `amount`
- Handle status changes from `"prepared"` to `"aborted"`

**Example:**
```typescript
await settlement.abort(handle.handle_id, "Negotiation failed");

// Idempotent: safe to call multiple times
await settlement.abort(handle.handle_id); // No-op, already aborted
```

### Idempotency

All lifecycle operations are **idempotent** to enable safe retries:

- **`prepare()`**: Same `(intent_id, idempotency_key)` returns same handle (no double-locking)
- **`commit()`**: Same `handle_id` returns same result (no double-payment)
- **`abort()`**: Same `handle_id` succeeds (idempotent abort is safe)

**Handle ID Generation:**
- Deterministic: `SHA-256(intent_id + ":" + idempotency_key)`
- Encoded as base58 for shorter IDs
- Same inputs → same handle_id → same handle

**Example (Retry Safety):**
```typescript
// Network failure during prepare - safe to retry
let handle: SettlementHandle;
try {
  handle = await settlement.prepare(intent);
} catch (error) {
  // Retry (idempotent)
  handle = await settlement.prepare(intent); // Returns same handle if first succeeded
}

// Network failure during commit - safe to retry
try {
  await settlement.commit(handle.handle_id);
} catch (error) {
  // Retry (idempotent)
  await settlement.commit(handle.handle_id); // No double-payment
}
```

### Integration with Existing Code

The lifecycle API is **additive** and does not replace existing settlement methods:

- **Existing methods unchanged**: `lock()`, `pay()`, `release()`, `slashBond()`, etc.
- **Backward compatible**: All v1.5 demos work unchanged
- **MockSettlementProvider**: Implements lifecycle using existing methods internally

**Minimal Integration:**
- Exchange/engine code continues using existing settlement methods
- Lifecycle API is available but not required (opt-in)
- Future integration with external payment rails will use lifecycle API

### Implementation Status

- **MockSettlementProvider**: ✅ Full implementation with idempotency
- **ExternalSettlementProvider**: ✅ Stub implementation (throws `NotImplemented`)
- **Integration**: TODO (existing code unchanged, lifecycle available but not used)

### Testing

Comprehensive tests cover:
- ✅ Prepare idempotency (same handle for same inputs)
- ✅ Commit idempotency (no double-payment)
- ✅ Abort idempotency (safe repeated calls)
- ✅ State transitions (prepare → commit, prepare → abort)
- ✅ Error handling (insufficient balance, invalid states)
- ✅ Handle ID determinism (same inputs → same handle_id)

See `packages/sdk/src/settlement/__tests__/lifecycle.test.ts` for full test coverage.

### Backward Compatibility

All v1.5 guarantees remain unchanged:
- ✅ Existing settlement methods work identically
- ✅ Demos continue to work unchanged
- ✅ Protocol semantics unchanged (lifecycle is settlement-layer only)

**Additive changes only**: v1.6.1 adds optional lifecycle API without breaking v1.5 behavior.

---

## Settlement Provider Selection (v1.6.2+)

v1.6.2 adds explicit settlement provider selection via `acquire()` input configuration, enabling runtime selection between mock and external providers while maintaining full backward compatibility.

### Overview

The settlement provider selection feature allows buyers to specify which settlement provider to use via `input.settlement` configuration, enabling:

- **Runtime provider selection**: Choose provider at request time without code changes
- **External provider integration**: Prepare for real payment rail integration
- **Backward compatibility**: Default behavior unchanged (existing demos work unchanged)

### Configuration

Settlement provider selection is configured via `input.settlement`:

```typescript
const result = await acquire({
  input: {
    intentType: "weather.data",
    scope: "NYC",
    constraints: { latency_ms: 50, freshness_sec: 10 },
    maxPrice: 0.0001,
    // Settlement provider selection (v1.6.2+)
    settlement: {
      provider: "mock" | "external",
      params?: Record<string, unknown>,  // Parameters for external provider
      idempotency_key?: string,          // Optional idempotency key for lifecycle
    },
  },
  // ... other params
});
```

**Fields:**
- `provider`: Settlement provider type (`"mock"` or `"external"`)
- `params`: Provider-specific parameters (required for `"external"`)
  - For `"external"`: Requires `{ rail: string, network?: string, credentials?: unknown }`
- `idempotency_key`: Optional idempotency key for settlement lifecycle operations (v1.6.1+)

### Provider Types

#### Mock Provider

Default provider for tests and demos:

```typescript
settlement: {
  provider: "mock",
}
```

- In-memory account balances
- Synchronous operations
- No external dependencies
- Suitable for testing and demos

#### External Provider

Stub for real payment rail integration:

```typescript
settlement: {
  provider: "external",
  params: {
    rail: "stripe",        // Payment rail identifier
    network: "testnet",    // Optional: network identifier
    credentials: { ... },  // Optional: API keys, wallet seeds, etc.
  },
}
```

- Currently throws `NotImplemented` errors
- Template for real implementations (Stripe, Ethereum, Solana, etc.)
- Requires implementation to work

**Example External Providers:**
- `rail: "stripe"` → Stripe payment API
- `rail: "ethereum"` → Ethereum smart contracts
- `rail: "solana"` → Solana program integration
- `rail: "custodial"` → Custodial wallet API

### Precedence

Settlement provider selection follows this precedence:

1. **`input.settlement.provider`** (highest priority)
   - If provided, creates provider via factory
   - Overrides explicit `settlement` parameter

2. **Explicit `settlement` parameter** (backward compatible)
   - If no `input.settlement.provider`, uses explicit parameter
   - Maintains backward compatibility with existing code

3. **Default behavior** (fallback)
   - Demos pass explicit `MockSettlementProvider`
   - This continues to work unchanged

**Example:**
```typescript
// Explicit settlement parameter wins (if no input.settlement.provider)
await acquire({
  input: { /* ... */ },  // No settlement config
  settlement: mockProvider,  // Uses this
  // ...
});

// Input config wins (if provided)
await acquire({
  input: {
    // ...
    settlement: { provider: "external", params: { rail: "stripe" } },
  },
  settlement: mockProvider,  // Ignored - input config used instead
  // ...
});
```

### Error Handling

When `provider: "external"` is selected, settlement operations throw `NotImplemented` errors. These are caught and returned as clean `acquire()` failures:

**Error Code:** `SETTLEMENT_PROVIDER_NOT_IMPLEMENTED`

**Example:**
```typescript
const result = await acquire({
  input: {
    // ...
    settlement: {
      provider: "external",
      params: { rail: "stripe" },
    },
  },
  // ...
});

if (!result.ok && result.code === "SETTLEMENT_PROVIDER_NOT_IMPLEMENTED") {
  console.error(`External settlement provider not implemented: ${result.reason}`);
}
```

**Error Handling Points:**
- Provider creation (factory errors)
- Settlement operations (credit, unlock, streamTick, etc.)
- Exchange operations (streaming tick, commit, etc.)

All `NotImplemented` errors from `ExternalSettlementProvider` are caught and returned as `SETTLEMENT_PROVIDER_NOT_IMPLEMENTED` with a descriptive reason.

### Factory Function

The settlement provider factory (`createSettlementProvider`) creates provider instances:

```typescript
import { createSettlementProvider } from "@pact/sdk";

const provider = createSettlementProvider({
  provider: "mock",
});

// or

const externalProvider = createSettlementProvider({
  provider: "external",
  params: {
    rail: "stripe",
    network: "testnet",
  },
});
```

**Factory Behavior:**
- `provider: "mock"` → Returns `new MockSettlementProvider()`
- `provider: "external"` → Returns `new ExternalSettlementProvider(params)`
- Invalid provider → Throws `Error` with clear message
- Missing params for external → Throws `Error` with validation message

### Usage Examples

**Mock Provider (Default):**
```typescript
const result = await acquire({
  input: {
    // ...
    settlement: {
      provider: "mock",
    },
  },
  // ... other params
});
```

**External Provider (Stub):**
```typescript
const result = await acquire({
  input: {
    // ...
    settlement: {
      provider: "external",
      params: {
        rail: "stripe",
        network: "testnet",
        credentials: {
          apiKey: process.env.STRIPE_API_KEY,
        },
      },
    },
  },
  // ... other params
});

if (!result.ok && result.code === "SETTLEMENT_PROVIDER_NOT_IMPLEMENTED") {
  // External provider not implemented yet
  console.warn("Real payment rail integration pending");
}
```

**With Idempotency Key:**
```typescript
const result = await acquire({
  input: {
    // ...
    settlement: {
      provider: "mock",
      idempotency_key: "retry-abc-123",  // For lifecycle operations
    },
  },
  // ... other params
});
```

### Integration with Lifecycle API

Settlement provider selection integrates with the lifecycle API (v1.6.1+):

- `idempotency_key` from `input.settlement` is available for lifecycle operations
- External providers can implement lifecycle methods (`prepare`, `commit`, `abort`)
- Mock provider fully implements lifecycle API with idempotency

**Example:**
```typescript
const result = await acquire({
  input: {
    // ...
    settlement: {
      provider: "mock",
      idempotency_key: "intent-123-retry-1",  // Used in prepare()
    },
  },
  // ... other params
});

// Lifecycle operations can use the idempotency_key from input.settlement
```

### Backward Compatibility

All v1.6.1 guarantees remain unchanged:
- ✅ Default behavior: No `input.settlement.provider` → uses explicit `settlement` parameter (unchanged)
- ✅ Existing demos work unchanged (pass explicit `MockSettlementProvider`)
- ✅ Protocol semantics unchanged (provider selection is settlement-layer only)

**Additive changes only**: v1.6.2 adds optional provider selection without breaking v1.6.1 behavior.

---

## Settlement Lifecycle in Transcripts (v1.6.3+)

v1.6.3 adds settlement lifecycle metadata to transcripts, enabling audit trails and replay validation for settlement operations.

### Overview

Transcripts now include optional `settlement_lifecycle` metadata that records:

- **Provider type**: Which settlement provider was used (`"mock"` or `"external"`)
- **Idempotency key**: The idempotency key from `input.settlement.idempotency_key` (if provided)
- **Lifecycle status**: Current lifecycle state (`"prepared"`, `"committed"`, or `"aborted"`)
- **Timestamps**: When lifecycle operations occurred (`prepared_at_ms`, `committed_at_ms`, `aborted_at_ms`)
- **Paid amount**: Amount paid (for committed settlements)
- **Errors**: Array of lifecycle errors (if any)

### Transcript Schema

```typescript
interface TranscriptV1 {
  // ... existing fields ...
  settlement_lifecycle?: {
    provider?: string;                    // "mock" | "external"
    idempotency_key?: string;             // From input.settlement.idempotency_key
    handle_id?: string;                   // Settlement handle ID from prepare()
    status?: "prepared" | "committed" | "aborted";
    prepared_at_ms?: number;              // Timestamp when prepare() was called
    committed_at_ms?: number;             // Timestamp when commit() was called
    aborted_at_ms?: number;               // Timestamp when abort() was called
    paid_amount?: number;                 // Amount paid (from commit result)
    errors?: Array<{                      // Lifecycle errors
      code: string;
      reason: string;
    }>;
  };
}
```

### Recording Lifecycle Metadata

Lifecycle metadata is automatically recorded when transcripts are saved:

**Provider Selection:**
- If `input.settlement.provider` is set, it's recorded in `settlement_lifecycle.provider`
- If `input.settlement.idempotency_key` is set, it's recorded in `settlement_lifecycle.idempotency_key`

**Status Recording:**
- On successful completion: `status: "committed"` with `paid_amount` and `committed_at_ms`
- On errors: `status: "aborted"` with `errors` array and `aborted_at_ms`
- Lifecycle errors are recorded when settlement operations fail (e.g., `SETTLEMENT_PROVIDER_NOT_IMPLEMENTED`)

**Example:**
```typescript
const result = await acquire({
  input: {
    intentType: "weather.data",
    scope: "NYC",
    constraints: { latency_ms: 50, freshness_sec: 10 },
    maxPrice: 0.0001,
    settlement: {
      provider: "mock",
      idempotency_key: "retry-abc-123",
    },
    saveTranscript: true,
    transcriptDir: ".pact/transcripts",
  },
  // ... other params
});

// Transcript includes:
// settlement_lifecycle: {
//   provider: "mock",
//   idempotency_key: "retry-abc-123",
//   status: "committed",
//   committed_at_ms: 1710000000,
//   paid_amount: 0.0001,
// }
```

### Replay Validation

The transcript replay verifier (`replayTranscript`) validates settlement lifecycle invariants:

**Validation Rules:**
- If `status === "committed"`: `paid_amount` must be present and > 0, `committed_at_ms` must be present
- If `status === "aborted"`: `paid_amount` must be absent or 0
- If `status === "prepared"`: `handle_id` must be present, `prepared_at_ms` must be present

**Validation Failures:**
- Failure code: `SETTLEMENT_LIFECYCLE_INVALID`
- Recorded in `replayResult.failures` with descriptive reason
- Does not throw; records failures in result

**Example:**
```typescript
import { replayTranscript } from "@pact/sdk";

const result = await replayTranscript(transcriptPath);

if (!result.ok) {
  for (const failure of result.failures) {
    if (failure.code === "SETTLEMENT_LIFECYCLE_INVALID") {
      console.error(`Settlement lifecycle invalid: ${failure.reason}`);
    }
  }
}

// Summary includes:
// summary.settlement_lifecycle_verified: number
// summary.settlement_lifecycle_failed: number
```

### Usage Examples

**Successful Settlement (Committed):**
```typescript
const transcript: TranscriptV1 = {
  // ... other fields ...
  outcome: { ok: true },
  settlement_lifecycle: {
    provider: "mock",
    idempotency_key: "test-key-123",
    status: "committed",
    committed_at_ms: 1710000000,
    paid_amount: 0.001,
  },
};

const result = await replayTranscript(transcript);
expect(result.ok).toBe(true);
expect(result.summary.settlement_lifecycle_verified).toBeGreaterThan(0);
```

**Failed Settlement (Aborted):**
```typescript
const transcript: TranscriptV1 = {
  // ... other fields ...
  outcome: {
    ok: false,
    code: "SETTLEMENT_PROVIDER_NOT_IMPLEMENTED",
  },
  settlement_lifecycle: {
    provider: "external",
    idempotency_key: "test-key-external",
    status: "aborted",
    aborted_at_ms: 1710000000,
    errors: [
      {
        code: "SETTLEMENT_PROVIDER_NOT_IMPLEMENTED",
        reason: "Settlement operation (credit) failed: ExternalSettlementProvider not implemented",
      },
    ],
  },
};

const result = await replayTranscript(transcript);
expect(result.ok).toBe(false);
expect(result.failures.some(f => f.code === "SETTLEMENT_LIFECYCLE_INVALID")).toBe(false); // Valid aborted state
```

**Invalid Transcript (Validation Failure):**
```typescript
const invalidTranscript: TranscriptV1 = {
  // ... other fields ...
  settlement_lifecycle: {
    provider: "mock",
    status: "committed",
    committed_at_ms: 1710000000,
    // paid_amount missing - invalid!
  },
};

const result = await replayTranscript(invalidTranscript);
expect(result.ok).toBe(false);
expect(result.failures.some(f => f.code === "SETTLEMENT_LIFECYCLE_INVALID")).toBe(true);
expect(result.summary.settlement_lifecycle_failed).toBeGreaterThan(0);
```

### Testing

Comprehensive tests cover:
- ✅ Lifecycle metadata recording for successful settlements
- ✅ Lifecycle error recording for failed settlements
- ✅ Replay validation of lifecycle invariants
- ✅ Invalid state detection (committed without paid_amount, aborted with paid_amount > 0, etc.)

See `packages/sdk/src/transcript/__tests__/settlement_lifecycle.test.ts` for full test coverage.

### Backward Compatibility

All v1.6.2 guarantees remain unchanged:
- ✅ `settlement_lifecycle` is optional (transcripts without it are valid)
- ✅ Existing transcript replay continues to work unchanged
- ✅ Protocol semantics unchanged (lifecycle metadata is audit-only)

**Additive changes only**: v1.6.3 adds optional lifecycle metadata to transcripts without breaking v1.6.2 behavior.

---

## Settlement Provider Routing (v1.6.2+, Option B1)

v1.6.2 introduces policy-driven settlement provider routing, allowing deterministic selection of settlement providers based on transaction characteristics and trust metrics.

### Overview

Settlement provider routing enables automatic selection of the appropriate settlement provider (`mock`, `stripe_like`, or `external`) based on policy rules evaluated against transaction context (amount, mode, trust tier, trust score).

**Key Principles:**
- **Deterministic**: Same context always selects the same provider
- **Policy-driven**: Rules defined in policy, not hardcoded
- **Backward compatible**: Defaults to `mock` provider if no routing rules match
- **Explicit override wins**: If caller provides explicit `settlement` instance or `input.settlement.provider`, routing is bypassed

### Policy Configuration

Add `settlement_routing` block to your policy:

```typescript
interface SettlementRouting {
  default_provider: "mock" | "stripe_like" | "external";  // Default provider
  rules: SettlementRoutingRule[];                          // Ordered rules (first match wins)
}

interface SettlementRoutingRule {
  when?: {
    min_amount?: number;              // Minimum amount (inclusive)
    max_amount?: number;              // Maximum amount (inclusive)
    mode?: "hash_reveal" | "streaming";  // Settlement mode
    min_trust_tier?: "untrusted" | "low" | "trusted";  // Minimum trust tier
    min_trust_score?: number;         // Minimum trust score (0.0-1.0)
  };
  use: "mock" | "stripe_like" | "external";  // Provider to use if rule matches
}
```

**Defaults:**
- `default_provider`: `"mock"`
- `rules`: `[]` (empty array, so behavior unchanged)

**Rule Evaluation:**
- Rules are evaluated in order (first match wins)
- All `when` conditions must match for rule to apply
- Amount comparisons are inclusive (`min_amount <= amount <= max_amount`)
- Trust tier hierarchy: `untrusted < low < trusted`
- `undefined` constraints are ignored (no constraint)

### Example Policy

```typescript
{
  "settlement_routing": {
    "default_provider": "mock",
    "rules": [
      {
        "when": {
          "min_trust_tier": "trusted",
          "max_amount": 0.001
        },
        "use": "stripe_like"
      },
      {
        "when": {
          "min_amount": 0.001
        },
        "use": "external"
      }
    ]
  }
}
```

This policy:
- Uses `stripe_like` for trusted providers with amount ≤ 0.001
- Uses `external` for any transaction with amount ≥ 0.001
- Uses `mock` (default) for all other cases

### Usage

Routing is automatically applied in `acquire()` when:
- No explicit `settlement` parameter is provided
- No `input.settlement.provider` is specified

**Explicit Override:**
```typescript
// Explicit settlement instance wins (routing bypassed)
const result = await acquire({
  input: { ... },
  settlement: new MockSettlementProvider(),  // Explicit instance
  ...
});

// Explicit input.settlement.provider wins (routing bypassed)
const result = await acquire({
  input: {
    settlement: { provider: "stripe_like" },  // Explicit provider
    ...
  },
  ...
});

// Routing applies (no explicit settlement)
const result = await acquire({
  input: { ... },  // No settlement config
  // No explicit settlement parameter
  ...
});
```

### Routing Context

Routing decisions are based on the following context (determined after provider selection):

- **amount**: Quote price from selected provider (used as estimate since routing happens before negotiation completes; actual agreed price may differ slightly)
- **mode**: Settlement mode (`hash_reveal` or `streaming`)
- **trust_tier**: Trust tier of selected provider (`untrusted`, `low`, or `trusted`)
- **trust_score**: Trust score of selected provider (0.0-1.0, clamped if outside valid range)

### Transcript Metadata

When routing is applied, the decision is recorded in the transcript:

```typescript
{
  "settlement_lifecycle": {
    "provider": "stripe_like",  // Selected provider
    "routing": {
      "matched_rule_index": 0,  // Index of matched rule (if any)
      "reason": "Matched rule 0 (conditions: {...}) -> stripe_like",
      "context": {
        "amount": 0.00005,  // Quote price used for routing (actual agreed price may differ)
        "mode": "hash_reveal",
        "trust_tier": "trusted",  // Validated (defaults to "untrusted" if invalid)
        "trust_score": 0.85  // Clamped to [0.0, 1.0] if outside range
      }
    }
  }
}
```

### Backward Compatibility

- Existing code with explicit `settlement` parameter continues to work unchanged
- Existing code with `input.settlement.provider` continues to work unchanged
- Default behavior (no routing config) uses `mock` provider, maintaining backward compatibility

---

## Provider Fallback Graph (v1.6.2+, Option B2)

v1.6.2 introduces provider fallback with retryable failure handling, enabling automatic retry with alternative eligible providers when the first attempt fails with a retryable error.

### Overview

The provider fallback mechanism enables:

- **Automatic retry**: If the first selected provider/settlement attempt fails with a retryable error, try the next eligible provider in order
- **Attempt chain recording**: Record every attempt in the transcript, including provider, outcome, and failure details
- **Deterministic behavior**: Only retry on retryable failures; stop immediately on non-retryable failures (e.g., `FAILED_PROOF`, credential/trust/policy failures)

**Key Principles:**
- **Protocol semantics unchanged**: Envelopes, negotiation, and receipts remain unchanged
- **Eligibility checks unchanged**: Only retry across already-eligible providers (credentials/trust/policy checks happen before fallback loop)
- **Retry policy**: Explicit list of retryable vs. non-retryable failure codes
- **Full transcript**: Attempt chain is recorded in transcript even on final failure

### Retry Policy

The fallback mechanism distinguishes between **retryable** and **non-retryable** failures:

#### Retryable Failures

These failures indicate temporary issues or provider-specific problems that might be resolved by trying a different provider:

- `SETTLEMENT_FAILED`: Settlement provider commit failure
- `SETTLEMENT_POLL_TIMEOUT`: Settlement polling timed out
- `SETTLEMENT_PENDING_UNRESOLVED`: Settlement stuck in pending state
- `SETTLEMENT_PROVIDER_NOT_IMPLEMENTED`: Settlement provider not available
- `PROVIDER_QUOTE_HTTP_ERROR`: HTTP error when fetching provider quote
- `PROVIDER_QUOTE_PARSE_ERROR`: Failed to parse provider quote
- `PROVIDER_SIGNATURE_INVALID`: Provider signature verification failed
- `PROVIDER_SIGNER_MISMATCH`: Provider signer mismatch
- `PROVIDER_QUOTE_INVALID`: Provider quote invalid
- `HTTP_PROVIDER_ERROR`: Generic HTTP errors from provider
- `HTTP_STREAMING_ERROR`: HTTP errors during streaming
- `INVALID_MESSAGE_TYPE`: Invalid message from provider
- `UNEXPECTED_ERROR`: Unexpected errors (treated as retryable)

#### Non-Retryable Failures

These failures indicate protocol-level or policy violations that cannot be resolved by trying a different provider:

- `FAILED_PROOF`: Proof verification failed (protocol-level failure)
- `PROVIDER_CREDENTIAL_*`: Any credential-related failure (e.g., `PROVIDER_CREDENTIAL_INVALID`, `PROVIDER_CREDENTIAL_EXPIRED`)
- `PROVIDER_TRUST_*`: Any trust-related failure (e.g., `PROVIDER_TRUST_TIER_INSUFFICIENT`, `PROVIDER_TRUST_SCORE_TOO_LOW`)
- `POLICY_*`: Any policy constraint violation (e.g., `POLICY_CONSTRAINT_VIOLATION`, `POLICY_INVALID_MODE`)
- `UNTRUSTED_ISSUER`: Untrusted credential issuer
- `MISSING_REQUIRED_CREDENTIALS`: Missing required credentials
- `QUOTE_OUT_OF_BAND`: Quote out of acceptable range
- `FAILED_REFERENCE_BAND`: Reference price band violation
- `SETTLEMENT_MODE_NOT_ALLOWED`: Settlement mode not allowed by policy
- `PRE_SETTLEMENT_LOCK_REQUIRED`: Pre-settlement lock required but not provided
- `BOND_INSUFFICIENT`: Insufficient bond
- `SCHEMA_VALIDATION_FAILED`: Schema validation failed
- `INVALID_POLICY`: Invalid policy configuration
- `NO_AGREEMENT`: No agreement reached (protocol failure)
- `NO_RECEIPT`: No receipt generated (protocol failure)
- `STREAMING_NOT_CONFIGURED`: Streaming mode not configured

**Important**: `FAILED_PROOF` and trust/policy failures are **never** retried. These indicate fundamental violations that cannot be resolved by trying a different provider.

### Fallback Plan

The fallback mechanism uses an ordered list of eligible providers:

1. **Primary provider**: First-choice provider (selected via existing provider selection logic)
2. **Fallback providers**: Remaining eligible providers in original order

**Ordering Rules:**
- Primary candidate is placed first
- Remaining candidates follow in their original order (as determined by directory fanout and selection logic)
- Order is deterministic based on provider selection criteria (price, latency, trust, etc.)

### Attempt Chain in Transcript

Every settlement attempt is recorded in the transcript via the `settlement_attempts` array:

```typescript
interface TranscriptV1 {
  // ... existing fields ...
  settlement_attempts?: Array<{
    idx: number;                      // Attempt index (0-based, ordered by attempt order)
    provider_pubkey: string;          // Provider public key (base58)
    provider_id?: string;             // Provider ID (if available)
    settlement_provider?: string;     // Settlement provider used ("mock", "stripe_like", "external")
    outcome: "success" | "failed";    // Outcome of this attempt
    failure_code?: string;            // Failure code (if outcome is "failed")
    failure_reason?: string;          // Failure reason (if outcome is "failed")
    timestamp_ms?: number;            // Timestamp when attempt completed
  }>;
}
```

**Recording Rules:**
- Each attempt is recorded with a unique `idx` (0-based, ordered by attempt order)
- Successful attempts record `outcome: "success"` (no `failure_code` or `failure_reason`)
- Failed attempts record `outcome: "failed"` with `failure_code` and `failure_reason`
- `settlement_provider` is recorded for each attempt (from routing or explicit selection)
- Attempt chain is recorded even on final failure (all attempts recorded in transcript)

**Example Transcript:**
```json
{
  "settlement_attempts": [
    {
      "idx": 0,
      "provider_pubkey": "provider1-pubkey",
      "provider_id": "provider1",
      "settlement_provider": "external",
      "outcome": "failed",
      "failure_code": "SETTLEMENT_PROVIDER_NOT_IMPLEMENTED",
      "failure_reason": "Settlement provider routing selected 'external' but creation failed: External settlement provider requires 'params' with 'rail' field",
      "timestamp_ms": 1710000000
    },
    {
      "idx": 1,
      "provider_pubkey": "provider2-pubkey",
      "provider_id": "provider2",
      "settlement_provider": "mock",
      "outcome": "success",
      "timestamp_ms": 1710000100
    }
  ]
}
```

### Fallback Behavior

The fallback mechanism operates as follows:

1. **Build ordered candidates**: Use `buildFallbackPlan()` to order eligible providers (primary first, then fallbacks)
2. **For each candidate**:
   - Attempt acquisition/settlement with this provider
   - If success: Record attempt (`outcome: "success"`) and return success
   - If failure:
     - Record attempt (`outcome: "failed"`, `failure_code`, `failure_reason`)
     - If `!isRetryableFailure(code)`: Stop and return failure immediately
     - Else: Continue to next candidate
3. **If all candidates fail**: Return last failure (or `NO_ELIGIBLE_PROVIDERS` if none eligible)

**Important Constraints:**
- Provider eligibility checks (credentials, trust, policy) happen **before** entering the fallback loop
- Only retry across already-eligible providers (no re-evaluation of eligibility during retry)
- Seller bond unlock/cleanup happens correctly per attempt (no leaked locks)
- Transcript includes the full attempt chain even on final failure

### Settlement Provider Routing Integration

Fallback integrates with settlement provider routing (B1):

- **Per-attempt routing**: For each candidate attempt, compute settlement provider choice independently based on routing rules
- **Routing recorded per attempt**: Each attempt records the settlement provider name in the attempt entry
- **Routing failures are retryable**: If settlement provider selection fails (e.g., not implemented), treat that as retryable and move to next candidate

**Example:**
- Provider 1 (untrusted tier) → Routing selects "external" → Fails with `SETTLEMENT_PROVIDER_NOT_IMPLEMENTED` (retryable) → Retry
- Provider 2 (trusted tier) → Routing selects "mock" → Succeeds

### Usage

Fallback is automatically enabled in `acquire()` when multiple eligible providers are available:

```typescript
const result = await acquire({
  input: {
    intentType: "weather.data",
    scope: "NYC",
    constraints: { latency_ms: 50, freshness_sec: 10 },
    maxPrice: 0.0001,
    saveTranscript: true,
    transcriptDir: ".pact/transcripts",
  },
  directory: providerDirectory,  // Multiple eligible providers
  // ... other params
});

if (result.ok && result.transcriptPath) {
  const transcript = JSON.parse(fs.readFileSync(result.transcriptPath, "utf-8"));
  
  // Check attempt chain
  if (transcript.settlement_attempts) {
    console.log(`Attempts: ${transcript.settlement_attempts.length}`);
    for (const attempt of transcript.settlement_attempts) {
      console.log(`Attempt ${attempt.idx}: ${attempt.provider_id} -> ${attempt.outcome}`);
      if (attempt.outcome === "failed") {
        console.log(`  Failed: ${attempt.failure_code} - ${attempt.failure_reason}`);
      }
    }
  }
}
```

### Error Handling

**Retryable Failure Example:**
```typescript
// First provider uses "external" settlement (not implemented) -> retryable
// Second provider uses "mock" settlement -> succeeds
const result = await acquire({ ... });
// result.ok === true
// transcript.settlement_attempts has 2 entries: failed, then success
```

**Non-Retryable Failure Example:**
```typescript
// First provider fails with FAILED_PROOF -> non-retryable, stop immediately
const result = await acquire({ ... });
// result.ok === false
// result.code === "FAILED_PROOF"
// transcript.settlement_attempts has 1 entry: failed (no retry attempted)
```

### Testing

Comprehensive tests cover:
- ✅ `isRetryableFailure()`: Correctly identifies retryable vs. non-retryable failures
- ✅ `buildFallbackPlan()`: Orders candidates correctly (primary first, then fallbacks)
- ✅ Fallback loop: Retries on retryable failures, stops on non-retryable failures
- ✅ Transcript recording: All attempts recorded in transcript (success and failure)
- ✅ Settlement provider routing integration: Routing works correctly per attempt

See `packages/sdk/src/settlement/__tests__/fallback.test.ts` for unit tests and `packages/sdk/src/client/__tests__/acquire.test.ts` for integration tests.

### Backward Compatibility

All v1.6.2 (B1) guarantees remain unchanged:
- ✅ Existing demos work unchanged (single-provider scenarios unaffected)
- ✅ Protocol semantics unchanged (envelopes, negotiation, receipts unchanged)
- ✅ Eligibility checks unchanged (credentials/trust/policy checks happen before fallback)
- ✅ Default behavior: Single eligible provider → no fallback (behavior unchanged)

**Additive changes only**: v1.6.2 (B2) adds fallback mechanism without breaking v1.6.2 (B1) behavior.

---

## Disputes and Challenge Window (v1.6.5+, C1)

v1.6.5 introduces a dispute resolution system that allows buyers to challenge receipts within a configurable time window, with transcript-backed evidence and settlement provider refund support.

### Overview

The dispute system provides:

- **Opt-in via policy**: Disputes are disabled by default and must be explicitly enabled
- **Challenge window**: Configurable time window for opening disputes after receipt creation
- **Transcript-backed evidence**: Automatic linkage to transaction transcripts for audit trails
- **Settlement provider refunds**: Generic refund interface for reversing payments
- **Stub resolver**: Interface for dispute resolution (no real arbitrator implementation)

### Configuration

Disputes are configured via `policy.base.disputes`:

```typescript
policy.base.disputes = {
  enabled: true,              // Enable disputes (default: false)
  window_ms: 86400000,        // 24 hours in milliseconds (default: 0)
  allow_partial: true,        // Allow partial refunds (default: true)
  max_refund_pct: 1.0,        // Maximum refund percentage (default: 1.0)
};
```

### Opening a Dispute

Buyers can open a dispute against a receipt within the challenge window:

```typescript
import { openDispute } from "@pact/sdk";

const dispute = openDispute({
  receipt: receiptRecord,
  reason: "Service not delivered as promised",
  now: Date.now(),
  policy: myPolicy,
  transcriptPath: "/path/to/transcript.json",  // Optional
  settlementMeta: {                            // Optional
    settlement_provider: "mock",
    settlement_handle_id: "handle-123",
  },
  disputeDir: ".pact/disputes",                // Optional (defaults to .pact/disputes)
});
```

**Constraints:**
- Disputes must be enabled in policy (`base.disputes.enabled = true`)
- Window must be configured (`base.disputes.window_ms > 0`)
- Dispute must be opened within the window (receipt age <= window_ms)

**Dispute Record:**
- Stored as JSON in `.pact/disputes/{dispute_id}.json`
- Includes receipt linkage, transcript path, settlement metadata
- Evidence flags track available evidence (transcript, receipt, settlement events)

### Resolving a Dispute

Disputes can be resolved with three outcomes:

1. **NO_REFUND**: Dispute rejected, no refund
2. **REFUND_FULL**: Full refund to buyer
3. **REFUND_PARTIAL**: Partial refund (requires `allow_partial: true`)

```typescript
import { resolveDispute } from "@pact/sdk";

const resolved = resolveDispute({
  dispute_id: dispute.dispute_id,
  outcome: "REFUND_FULL",
  refund_amount: 0.1,  // Required for REFUND_FULL and REFUND_PARTIAL
  notes: "Refund approved after review",
  now: Date.now(),
  policy: myPolicy,
  settlementProvider: settlement,
  disputeDir: ".pact/disputes",
});
```

**Constraints:**
- Dispute must be in `OPEN` status
- Partial refunds require `allow_partial: true`
- Refund amount cannot exceed `max_refund_pct` of original amount
- Settlement provider must support `refund()` method

### Settlement Provider Refund Support

Settlement providers can optionally implement the `refund()` method:

```typescript
interface SettlementProvider {
  // ... existing methods ...
  
  refund?(
    fromAgentId: string,  // Seller (source of refund)
    toAgentId: string,    // Buyer (recipient)
    amount: number,       // Refund amount
    meta?: Record<string, unknown>  // Dispute metadata
  ): void | Promise<void>;
}
```

**Implementation Status:**
- ✅ **MockSettlementProvider**: Full implementation (transfers funds, throws `REFUND_INSUFFICIENT_FUNDS` if seller lacks balance)
- ✅ **StripeLikeSettlementProvider**: Delegates to underlying mock provider
- ❌ **ExternalSettlementProvider**: Throws `NotImplemented` (real implementations required)

### Transcript Linkage

Transcripts automatically include all information needed for dispute resolution:

- **Receipt**: `transcript.receipt` contains full receipt with `receipt_id`
- **Settlement Provider**: `transcript.settlement_lifecycle.provider` (e.g., "mock", "stripe_like")
- **Settlement Handle**: `transcript.settlement_lifecycle.handle_id` for idempotent settlement operations

When opening a dispute, the transcript path can be provided to link the dispute record to the full transaction transcript.

### Dispute Store

Dispute records are persisted to disk as JSON files:

- **Default location**: `.pact/disputes/`
- **File format**: `{dispute_id}.json`
- **Operations**: `createDispute()`, `loadDispute()`, `listDisputes()`, `updateDispute()`

### Resolver Interface

The resolver is a **stub implementation** - no real arbitrator is provided. The `resolveDispute()` function:

- Validates policy constraints
- Executes refund via settlement provider
- Updates dispute record status

Real implementations would integrate with:
- Arbitration services
- Governance systems
- Multi-signature wallets
- Automated dispute resolution logic

### Testing

Comprehensive tests cover:
- ✅ Policy validation (enabled, window_ms)
- ✅ Window expiration checks
- ✅ Dispute record creation and persistence
- ✅ Full refund execution
- ✅ Partial refund with max_refund_pct constraints
- ✅ Insufficient funds handling
- ✅ Settlement provider refund support

See `packages/sdk/src/disputes/__tests__/disputes.test.ts` for full test coverage.

### Backward Compatibility

All existing guarantees remain unchanged:
- ✅ Disputes are opt-in (disabled by default)
- ✅ Existing demos continue to work unchanged
- ✅ Protocol semantics unchanged (disputes are post-transaction)
- ✅ Settlement provider refund is optional (existing providers work without it)

**Additive changes only**: v1.6.5 adds dispute infrastructure without breaking existing behavior.

---

## Split Settlement (v1.6.6+, B3)

v1.6.6 introduces split settlement, allowing payment amounts to be fulfilled across multiple settlement providers in segments, with transcript-backed validation.

### Overview

Split settlement provides:

- **Opt-in only**: Disabled by default, must be explicitly enabled via `input.settlement.split.enabled`
- **Hash-reveal only**: Only works with `hash_reveal` settlement mode (streaming not supported)
- **Multi-provider segments**: Fulfills payment amount across multiple providers using fallback routing
- **Transcript recording**: All segments recorded in transcript for audit and replay validation
- **No automatic refunds**: Partial payments that succeed are not automatically refunded (disputes C2 handles that)

### Configuration

Split settlement is configured via `input.settlement.split`:

```typescript
const result = await acquire({
  input: {
    intentType: "weather.data",
    scope: "NYC",
    constraints: { latency_ms: 50, freshness_sec: 10 },
    maxPrice: 0.0001,
    settlement: {
      split: {
        enabled: true,        // Enable split settlement
        max_segments: 2,      // Maximum number of segments (optional, defaults to number of candidates)
      },
    },
  },
  // ... other params
});
```

### How It Works

When split settlement is enabled:

1. **Target amount**: The `agreed_price` from the ACCEPT message becomes the target amount
2. **Segment calculation**: Each segment amount is calculated as `min(remaining, target_amount / max_segments)`
3. **Provider selection**: For each segment, a settlement provider is chosen via routing rules (B1) based on:
   - Segment amount
   - Provider trust tier/score
   - Settlement mode (hash_reveal)
4. **Segment execution**: Each segment uses the settlement lifecycle API (prepare/commit) independently
5. **Fallback**: If a segment fails with a retryable error, the next candidate provider is tried
6. **Completion**: Split completes when `total_paid >= target_amount - epsilon` (float tolerance)

### Transcript Recording

Split settlement records detailed segment information in the transcript:

```typescript
{
  settlement_segments: [
    {
      idx: 0,
      provider_pubkey: "provider1...",
      settlement_provider: "mock",
      amount: 0.05,
      status: "committed",
      handle_id: "handle-123",
    },
    {
      idx: 1,
      provider_pubkey: "provider2...",
      settlement_provider: "stripe_like",
      amount: 0.05,
      status: "committed",
      handle_id: "handle-456",
    },
  ],
  settlement_split_summary: {
    enabled: true,
    target_amount: 0.1,
    total_paid: 0.1,
    segments_used: 2,
  },
}
```

### Replay Validation

The replay validator checks:

- ✅ Sum of committed segment amounts equals `total_paid`
- ✅ `total_paid <= target_amount + epsilon` (no overpay)
- ✅ If final outcome is success, `total_paid ≈ target_amount` (complete payment)
- ✅ Segment indices are monotonic (0, 1, 2, ...)
- ✅ `segments_used` matches committed segments count

### Failure Handling

**Important**: If split settlement fails partway (some segments committed, others failed):

- ✅ **No automatic refunds**: Funds already moved remain moved
- ✅ **Transcript records all segments**: Both committed and failed segments are recorded
- ✅ **Disputes handle refunds**: Use disputes (C2) to handle partial payment refunds if needed

This design ensures:
- **Audit trail**: Full history of all segment attempts
- **No double-spending**: Committed segments are not automatically reversed
- **Explicit refunds**: Refunds require explicit dispute resolution

### Constraints

- **Hash-reveal only**: Split settlement only works with `hash_reveal` mode (streaming not supported)
- **Requires routing**: Split settlement requires settlement provider routing (B1) to be configured
- **Requires candidates**: Split settlement requires multiple eligible providers (fallback candidates)
- **Lifecycle API**: Split settlement requires settlement providers to support the lifecycle API (prepare/commit)

### Testing

Tests verify:
- ✅ Split config is accepted without breaking normal operation
- ✅ Split settlement fails gracefully when conditions aren't met
- ✅ Transcript records segments correctly
- ✅ Replay validation passes for split settlements

See `packages/sdk/src/settlement/__tests__/split_settlement.test.ts` for test coverage.

### Backward Compatibility

All existing guarantees remain unchanged:
- ✅ Split settlement is opt-in (disabled by default)
- ✅ Existing demos continue to work unchanged
- ✅ Protocol semantics unchanged (split is settlement-layer only)
- ✅ Default behavior: Single settlement, no splitting (behavior unchanged)

**Additive changes only**: v1.6.6 adds split settlement infrastructure without breaking existing behavior.

---

## Settlement SLA (v1.6.7+, D1)

v1.6.7 introduces settlement SLA enforcement with timeout and poll attempt limits, transcripted violations, and optional reputation penalties.

### Overview

Settlement SLA provides:

- **Opt-in only**: Disabled by default, must be explicitly enabled via `base.settlement.settlement_sla.enabled`
- **Timeout enforcement**: Configurable limits on pending duration and poll attempts
- **Retryable violations**: SLA violations trigger fallback (B2) or split continuation (B3)
- **Transcript recording**: All violations recorded in transcript for audit
- **Optional penalties**: Minimal reputation penalty hook for providers causing violations

### Configuration

Settlement SLA is configured via `base.settlement.settlement_sla`:

```json
{
  "base": {
    "settlement": {
      "settlement_sla": {
        "enabled": true,
        "max_pending_ms": 5000,        // Total time allowed in pending status (0 = no limit)
        "max_poll_attempts": 10,        // Maximum poll attempts (0 = no limit)
        "poll_interval_ms": 100,         // Default poll interval if auto_poll_ms not set
        "penalty": {
          "enabled": true,
          "provider_penalty": 0.05,     // Reputation penalty for provider (0.0-1.0)
          "buyer_penalty": 0.0          // Reputation penalty for buyer (typically 0)
        }
      }
    }
  }
}
```

### How It Works

When settlement SLA is enabled:

1. **Poll interval**: Uses `input.settlement.auto_poll_ms` if set, otherwise `policy.poll_interval_ms`
2. **Max attempts**: Uses `policy.max_poll_attempts` if >0, otherwise existing default (100)
3. **Pending timeout**: Tracks elapsed time from first pending response
4. **Violation detection**:
   - If `elapsed_ms > max_pending_ms` (if >0): Violation with reason "pending exceeded SLA"
   - If `polls >= max_poll_attempts` (if >0): Violation with reason "poll attempts exceeded SLA"
5. **Failure code**: `SETTLEMENT_SLA_VIOLATION` (retryable, triggers fallback)
6. **Cleanup**: Abort/release locks and unlock bond before moving to next attempt

### Transcript Recording

SLA violations are recorded in the transcript:

```typescript
{
  settlement_sla: {
    enabled: true,
    max_pending_ms: 5000,
    max_poll_attempts: 10,
    poll_interval_ms: 100,
    violations: [
      {
        ts_ms: 1234567890,
        code: "SETTLEMENT_SLA_VIOLATION",
        reason: "poll attempts exceeded SLA: 10 >= 10",
        handle_id: "handle-123",
        provider: "StripeLikeSettlementProvider",
      },
    ],
  },
}
```

### Replay Validation

The replay validator checks:

- ✅ Each violation has `ts_ms` and `code`
- ✅ If final outcome is success, violations are allowed (fallback succeeded)
- ✅ If final outcome is failure, last violation should match final failure code if SLA was the reason

### Reputation Penalties

If `penalty.enabled` is true and a provider attempt ends with `SETTLEMENT_SLA_VIOLATION`:

- **Minimal hook**: Records a penalty receipt in `ReceiptStore` with:
  - `failure_code: "SETTLEMENT_SLA_VIOLATION"`
  - `paid_amount: 0` (zero paid amount)
  - `fulfilled: false`
- **Reputation impact**: The penalty receipt can be consumed by `agentScoreV2` for reputation calculations
- **No automatic scoring**: This is a minimal hook; actual reputation scoring is handled separately

### Fallback Integration

SLA violations are **retryable** and trigger fallback (B2):

- ✅ `SETTLEMENT_SLA_VIOLATION` is in the retryable codes list
- ✅ First provider hits SLA violation → fallback to next candidate
- ✅ Transcript records both attempts (failed with SLA violation, then success)
- ✅ Split settlement (B3) also respects SLA limits per segment

### Constraints

- **Settlement lifecycle only**: SLA enforcement applies to settlement lifecycle polling and pending states
- **Hash-reveal and streaming**: Works with both settlement modes
- **Requires auto-poll**: SLA enforcement requires `input.settlement.auto_poll_ms` to be set (or `policy.poll_interval_ms`)
- **No protocol changes**: SLA is enforcement-layer only, no envelope or negotiation changes

### Testing

Tests verify:
- ✅ SLA config is properly structured
- ✅ `SETTLEMENT_SLA_VIOLATION` is retryable in fallback logic
- ✅ SLA violations are recorded in transcript
- ✅ Replay validation passes for SLA violations

See `packages/sdk/src/engine/__tests__/sla.test.ts` for test coverage.

### Backward Compatibility

All existing guarantees remain unchanged:
- ✅ SLA is opt-in (disabled by default)
- ✅ Existing demos continue to work unchanged
- ✅ Protocol semantics unchanged (SLA is enforcement-layer only)
- ✅ Default behavior: No SLA enforcement (behavior unchanged)

**Additive changes only**: v1.6.7 adds settlement SLA infrastructure without breaking existing behavior.

---

## Dispute Resolution + Refunds (v1.6.8+, C2)

v1.6.8 introduces dispute resolution with refund/reversal semantics tied to settlement providers, transcripted and idempotent.

### Overview

Dispute resolution provides:

- **Actionable disputes**: Resolving a dispute can execute a refund (full/partial)
- **Idempotent refunds**: Same `dispute_id` cannot refund twice (idempotency via settlement provider)
- **Refund bounds**: Refund amount bounded by policy (`max_refund_pct`) and by what was paid
- **Transcript recording**: Resolution events recorded in transcript + dispute JSON record
- **Settlement provider integration**: Refunds executed via settlement provider's refund API

### Settlement Refund API

Settlement providers implement a first-class refund API:

```typescript
async refund(refund: {
  dispute_id: string;
  from: string;        // seller
  to: string;          // buyer
  amount: number;
  reason?: string;
  idempotency_key?: string;
}): Promise<{
  ok: boolean;
  refunded_amount: number;
  code?: string;
  reason?: string;
}>
```

**Idempotency**: If called multiple times with the same `dispute_id` (as `idempotency_key`), returns `ok=true` with the same `refunded_amount` without changing balances twice.

**Provider implementations**:
- **MockSettlementProvider**: Tracks processed refund idempotency keys; enforces sufficient balance; returns `REFUND_INSUFFICIENT_FUNDS` if seller lacks funds
- **StripeLikeSettlementProvider**: Same semantics; if original payment is still "pending", may return `REFUND_INSUFFICIENT_FUNDS`
- **ExternalSettlementProvider**: Returns `ok=false` with code `SETTLEMENT_PROVIDER_NOT_IMPLEMENTED`

### Dispute Resolution API

```typescript
async resolveDispute(args: {
  dispute_id: string;
  outcome: "NO_REFUND" | "REFUND_FULL" | "REFUND_PARTIAL";
  refund_amount?: number;
  notes?: string;
  now: () => number;
  policy: CompiledPolicy;
  disputeStore: DisputeStore;
  settlement: SettlementProvider;
  receipt: Receipt; // Must include buyer/seller ids and paid_amount
  transcriptPath?: string;
}): Promise<{
  ok: boolean;
  record?: DisputeRecord;
  code?: string;
  reason?: string;
}>
```

**Rules**:
1. Must load dispute record, ensure status `OPEN`
2. Enforce disputes enabled in policy
3. Enforce refund bounds:
   - `NO_REFUND`: `refund_amount=0`, mark resolved
   - `REFUND_FULL`: `refund_amount = min(paid_amount, agreed_price)` capped by `max_refund_pct` (typically 1.0)
   - `REFUND_PARTIAL`: require `refund_amount` provided and `<= paid_amount` and `<= max_refund_pct * paid_amount`
4. Call `settlement.refund({ dispute_id, from: seller, to: buyer, amount: refund_amount, idempotency_key: dispute_id })`
5. If refund fails, return `ok=false` with refund error code
6. Update dispute record: status `RESOLVED`, outcome, `refund_amount`, notes, `transcript_path` (if provided)

### Transcript Integration

Dispute events are recorded in the transcript:

```typescript
{
  dispute_events: [
    {
      ts_ms: 1234567890,
      dispute_id: "dispute-receipt-123-abc",
      outcome: "REFUND_FULL",
      refund_amount: 0.1,
      settlement_provider: "mock",
      status: "resolved",
      failure_code?: string,
      failure_reason?: string,
    },
  ],
}
```

**Transcript writing**:
- If `transcriptPath` is provided and file exists: append `dispute_events` to existing transcript
- If `transcriptPath` is provided but file doesn't exist: create a minimal dispute event file at `.pact/transcripts/<intent_id>-dispute-<dispute_id>.json`

### Replay Validation

The replay validator checks:

- ✅ `refund_amount >= 0`
- ✅ For resolved refunds: `refund_amount <= (receipt.paid_amount || receipt.agreed_price)`
- ✅ Idempotency: if multiple events for same `dispute_id`, they must not sum to `> paid_amount` (warn/fail)

### Idempotency

Refunds are **idempotent**:

- Same `dispute_id` cannot refund twice (enforced by settlement provider)
- Settlement provider tracks processed refund idempotency keys
- Repeated calls with same `dispute_id` return `ok=true` with same `refunded_amount` without changing balances
- Dispute record status prevents double-resolution (must be `OPEN` to resolve)

### Constraints

- **Requires receipt**: `resolveDispute` requires `receipt` parameter with `paid_amount` or `agreed_price`
- **Policy bounds**: Refund amount bounded by `max_refund_pct` and `allow_partial` settings
- **Settlement provider support**: Requires settlement provider to implement refund API (or returns `NOT_IMPLEMENTED`)
- **No protocol changes**: Refunds are settlement-layer only, no envelope or negotiation changes

### Testing

Tests verify:
- ✅ `resolveDispute` fails if disputes disabled
- ✅ `REFUND_FULL` refunds buyer and debits seller (mock settlement)
- ✅ `REFUND_PARTIAL` bounded by `max_refund_pct`
- ✅ Idempotency: resolving same dispute twice does not double-refund
- ✅ External settlement returns not implemented error cleanly
- ✅ Transcript dispute event written (if `transcriptPath` provided)

See `packages/sdk/src/disputes/__tests__/resolve.test.ts` for test coverage.

### Backward Compatibility

All existing guarantees remain unchanged:
- ✅ Refunds are opt-in (requires disputes enabled and `resolveDispute` called)
- ✅ Existing demos continue to work unchanged
- ✅ Protocol semantics unchanged (refunds are settlement-layer only)
- ✅ Default behavior: No refunds unless explicitly resolved

**Additive changes only**: v1.6.8 adds dispute resolution infrastructure without breaking existing behavior.

---

## Replay Verification Hardening (v1.6.0-alpha+, H1)

v1.6.0-alpha+ introduces replay verification hardening with transcript versioning, stronger invariants, and a CLI tool for transcript verification.

### Overview

Replay verification hardening provides:

- **Transcript versioning**: Optional `transcript_version` field for schema versioning
- **Stronger invariants**: Additional validation checks for settlement attempts, streaming attempts, segments, disputes, and reconciliation events
- **CLI tool**: `pnpm replay:verify` for verifying transcript files

### Transcript Versioning

Transcripts now include an optional `transcript_version` field:

```typescript
{
  version: "1",
  transcript_version?: "1.0",  // H1: Schema version (defaults to "1.0" if missing)
  intent_id: "intent-123",
  // ... rest of transcript
}
```

**Behavior:**
- New transcripts written by `acquire()` automatically set `transcript_version: "1.0"`
- Existing transcripts without `transcript_version` are treated as version "1.0" (backward compatible)
- Missing version generates a warning (not an error) during verification

### Replay Verification API

The `verifyTranscriptFile()` function provides stronger invariant checking:

```typescript
import { verifyTranscriptFile } from "@pact/sdk";

const result = await verifyTranscriptFile("transcript.json");

if (!result.ok) {
  for (const error of result.errors) {
    console.error(`ERROR: ${error}`);
  }
}

for (const warning of result.warnings) {
  console.warn(`WARNING: ${warning}`);
}
```

**Stronger Invariants:**

1. **settlement_attempts**: Last attempt outcome must match overall outcome
   - If overall `ok: true`, last attempt must be `success`
   - If overall `ok: false`, last attempt should be `failed`

2. **streaming_attempts**: 
   - Sum of successful attempt `paid_amount` must equal `total_paid_amount`
   - `total_paid_amount` must never exceed `agreed_price + epsilon`

3. **settlement_segments**: (Already validated in replay, but verified here)
   - Sum of committed segment amounts equals `total_paid`
   - `total_paid` never exceeds `target_amount + epsilon`

4. **dispute_events**:
   - `refund_amount` must not exceed `paid_amount` or `agreed_price`
   - No duplicate `dispute_id` summing above paid amount

5. **reconcile_events**:
   - `handle_id` must be present
   - `handle_id` must match `settlement_lifecycle.handle_id`
   - Valid transitions (pending → committed/failed)

### CLI Tool

The `replay:verify` CLI tool verifies transcript files:

```bash
# Verify a single file
pnpm replay:verify -- .pact/transcripts/intent-123.json

# Verify all transcripts in a directory
pnpm replay:verify -- .pact/transcripts
```

**Behavior:**
- Exit code 0 if all transcripts verify successfully
- Exit code 1 if any errors are found
- Prints errors and warnings for each file
- Supports single files or directories (recursively finds all `.json` files)

**Example Output:**
```
.pact/transcripts/intent-123.json:
  ⚠️  WARNING: transcript_version missing, assuming '1.0'
  ❌ ERROR: streaming_attempts: total_paid_amount (0.2) exceeds agreed_price (0.1)

=== Summary ===
Files verified: 1
Total errors: 1
Total warnings: 1

❌ Verification failed with 1 error(s)
```

### Testing

Comprehensive tests cover:
- ✅ Valid transcripts with version
- ✅ Missing version generates warning (not error)
- ✅ Invalid settlement_attempts outcome mismatch
- ✅ Invalid streaming_attempts total_paid_amount exceeds agreed_price
- ✅ Invalid dispute_events refund_amount exceeds paid_amount
- ✅ Invalid reconcile_events missing handle_id
- ✅ Non-existent file handling

See `packages/sdk/src/transcript/__tests__/verify_cli.test.ts` for full test coverage.

### Backward Compatibility

All existing guarantees remain unchanged:
- ✅ Transcripts without `transcript_version` are treated as "1.0" (backward compatible)
- ✅ Missing version generates warning, not error
- ✅ Existing replay validation continues to work unchanged
- ✅ Protocol semantics unchanged (verification is audit-only)

**Additive changes only**: H1 adds verification hardening without breaking existing behavior.

---

## What's Next

Possible future enhancements (not in v1.6):

- **External payment rail integration**: Real implementations of `ExternalSettlementProvider` for Stripe, Ethereum, etc.
- **Async settlement**: Support for async operations (e.g., on-chain confirmation)
- **Settlement webhooks**: Callback support for external payment rails
- **Multi-signature settlement**: Support for governance-required settlements

These features may be considered for future versions but are explicitly **not** in v1.6.

